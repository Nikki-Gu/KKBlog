import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as l,o as a,d as n}from"./app-CGyb9mVk.js";const t={},s=n(`<h2 id="基础" tabindex="-1"><a class="header-anchor" href="#基础"><span>基础</span></a></h2><p>现在的 Java 线程的本质其实就是操作系统的线程；<code>new Thread().start()</code>创建线程</p><p>线程模型：</p><ul><li>一对一：在 Windows 和 Linux 等主流操作系统中Java采用的模型</li><li>一对多</li><li>多对多</li></ul><h3 id="从-jvm-的角度来说一下线程和进程之间的关系" tabindex="-1"><a class="header-anchor" href="#从-jvm-的角度来说一下线程和进程之间的关系"><span>从 JVM 的角度来说一下线程和进程之间的关系</span></a></h3><p>线程共享的进程的如下资源：</p><ul><li>堆（字符串常量池）：存放几乎所有对象</li><li>方法区：存放已加载的类信息，常量、静态变量、即时编译器编译后的代码</li></ul><p>线程独有：</p><ul><li>虚拟机栈：为虚拟机执行字节码服务</li><li>本地方法栈：为虚拟机使用到的Native方法服务</li><li>程序计数器：记录当前线程执行位置，切换回来能找得到执行入口</li></ul><p>栈保证线程的局部变量不被其他线程访问</p><h3 id="多线程安全问题" tabindex="-1"><a class="header-anchor" href="#多线程安全问题"><span>多线程安全问题</span></a></h3><ul><li>内存泄漏</li><li>死锁</li><li>线程不安全：对同一份数据的访问不能保证其正确和一致</li></ul><h3 id="start和run的区别" tabindex="-1"><a class="header-anchor" href="#start和run的区别"><span>start和run的区别</span></a></h3><p>start会启动线程并让它处于就绪状态，之后自动执行run方法</p><p>直接调用run方法就是执行了一个普通方法，并不是启动线程</p><h3 id="sleep和wait方法区别" tabindex="-1"><a class="header-anchor" href="#sleep和wait方法区别"><span>sleep和wait方法区别</span></a></h3><p>都可以暂停线程</p><ul><li>锁：sleep不释放锁，wait释放锁</li><li>苏醒：sleep会自动苏醒，wait要么设置时长超时后苏醒，要么需要别的线程调用同一个对象上的notify方法苏醒线程</li><li>定义：sleep是Thread类的静态本地方法（不涉及对象和锁），wait是Object类的本地方法（本质是让获得对象锁的线程释放锁并等待）</li></ul><h2 id="volatile关键字" tabindex="-1"><a class="header-anchor" href="#volatile关键字"><span>volatile关键字</span></a></h2><ul><li>不保证原子性：因为不能确定并发编程的指令排序 <ul><li>例子：复合操作<code>inc++</code> ：读取、+1、写回内存</li></ul></li><li>保证可见性：标识变量是共享不稳定的，每次到主存中读取</li><li>保证有序性：禁止重排序</li></ul><h2 id="锁" tabindex="-1"><a class="header-anchor" href="#锁"><span>锁</span></a></h2><h3 id="悲观锁-独占锁" tabindex="-1"><a class="header-anchor" href="#悲观锁-独占锁"><span>悲观锁/独占锁</span></a></h3><p>比如<code>synchronized</code>、<code>ReentrantLock</code></p><p>适用场景：多写场景</p><h3 id="乐观锁" tabindex="-1"><a class="header-anchor" href="#乐观锁"><span>乐观锁</span></a></h3><p>线程提交修改的时候验证对应资源是否被其他线程修改：</p><ul><li>版本号机制 <ul><li>提交修改时的版本号要和数据的版本号相同才能提交，否则驳回</li></ul></li><li>CAS算法 <ul><li>实现：CAS 是一个原子操作，底层依赖于一条 CPU 原子指令 <ul><li><strong>V</strong>：要更新的变量值(Var)</li><li><strong>E</strong>：预期值(Expected)</li><li><strong>N</strong>：拟写入的新值(New)</li><li>当且仅当 V == E，更新V = N</li></ul></li><li>问题： <ul><li>ABA问题：加上版本号/时间戳</li><li>重复执行开销大</li><li>单个共享变量：JDK1.5之后使用<code>AtomicReference</code>保证引用对象的原子性</li></ul></li></ul></li></ul><p>适用场景：多读场景</p><h3 id="synchronized关键字" tabindex="-1"><a class="header-anchor" href="#synchronized关键字"><span>synchronized关键字</span></a></h3><p>保证原子性和可见性</p><h4 id="底层实现" tabindex="-1"><a class="header-anchor" href="#底层实现"><span>底层实现</span></a></h4><p>基于底层操作系统的互斥锁，使用对象监视器monitor实现，获取锁就是获取对应的Monitor对象的持有权</p><ul><li>语句块： <code>monitorenter</code> 和 <code>monitorexit</code> 指令</li><li>方法：<code>ACC_SYNCHRONIZED</code>标识</li></ul><h4 id="类别" tabindex="-1"><a class="header-anchor" href="#类别"><span>类别</span></a></h4><p>对象锁和类的锁是分开的两个锁，不冲突</p><ul><li>对象锁 <ul><li><code>synchronized(object)</code></li><li><code>synchronized void method() {}</code></li></ul></li><li>类的锁 <ul><li><code>synchronized(类.class)</code></li><li><code>synchronized static void method() {}</code></li></ul></li></ul><h4 id="双重校验锁实现对象单例" tabindex="-1"><a class="header-anchor" href="#双重校验锁实现对象单例"><span>双重校验锁实现对象单例</span></a></h4><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
  	<span class="token comment">// 使用volatile禁止指令重排，防止一个线程获得还没有初始化的实例</span>
    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> uniqueInstance<span class="token punctuation">;</span>

  	<span class="token comment">// 用private修饰构造函数，保证在外面不能new</span>
    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getUniqueInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码, 提高性能（锁的粒度小，并发度高）</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">//类对象加锁</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
              	<span class="token comment">//需要再判断一次，因为可能另外一个进程已经创建成功了让uniqueInstance != null</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    uniqueInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> uniqueInstance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="reentrantlock" tabindex="-1"><a class="header-anchor" href="#reentrantlock"><span>ReentrantLock</span></a></h3><ul><li>实现了<code>Lock</code>接口</li><li>使用内部类<code>Sync</code>实现 <ul><li><code>FairSync</code>：按时间先后分配锁（先到先得）</li><li><code>NonfairSync</code>: 默认；</li></ul></li></ul><p><code>Sync</code>继承 AQS <code>AbstractQueuedSynchronizer</code></p><h4 id="reentrantlock和synchronized区别" tabindex="-1"><a class="header-anchor" href="#reentrantlock和synchronized区别"><span>ReentrantLock和synchronized区别</span></a></h4><ul><li><p>都是可重入锁：线程可以再次获取自己的内部锁（获得了一个锁，这个锁锁住的都可以访问）</p><ul><li>ReentrantLock的可重入是通过AQS的state++来实现的</li></ul></li><li><p>ReentrantLock是API实现的，synchronized是JVM实现的</p></li><li><p>ReentrantLock功能更强大灵活</p><ul><li>需要显示申请和释放锁</li><li>可实现公平锁，synchronized只能是非公平锁</li><li>等待可中断： <ul><li><code>lock.tryLock(1, TimeUnit.SECONDS)</code></li><li><code>lock.lockInterruptibly()</code></li></ul></li><li>可实现选择性通知</li></ul></li></ul><h2 id="线程池" tabindex="-1"><a class="header-anchor" href="#线程池"><span>线程池</span></a></h2><p>线程池：提供一种限制和管理线程资源的方式，可以减少在创建和销毁线程上所消耗的时间以及系统资源开销</p><h3 id="创建" tabindex="-1"><a class="header-anchor" href="#创建"><span>创建</span></a></h3><ul><li><code>ExecutorService threadPool = ThreadPoolExecutor(参数);</code><ul><li>三个重要参数： <ul><li>核心线程数： <ul><li>CPU密集型线程：N+1（N是CPU核心数）</li><li>IO密集型线程：2N</li></ul></li><li>最大线程数</li><li>工作队列（workQueue）</li><li>饱和策略（handler）</li><li>keepAliveTime：线程数量大于核心线程数的线程存活时间 <ul><li>unit：时间单位</li></ul></li><li>threadFactory</li></ul></li></ul></li><li><code>Executors</code><ul><li>比如通过<code> Executors.newFixedThreadPool(3);</code>创建</li><li>底层实现也是通过<code>ThreadPoolExecutor</code>构造函数创建</li></ul></li></ul><p>动态配置参数：<code>ThreadPoolExecutor</code>提供set方法修改参数</p><h4 id="内置线程池" tabindex="-1"><a class="header-anchor" href="#内置线程池"><span>内置线程池</span></a></h4><ul><li><p><code>FixedThreadPool</code>：核心线程数和最大线程数相等；</p><ul><li>使用容量为 <code>Integer.MAX_VALUE</code> 的 <code>LinkedBlockingQueue</code>（无界队列）</li></ul></li><li><p><code>SingleThreadExector</code>：核心线程数和最大线程数等于1；</p><ul><li>使用容量为 <code>Integer.MAX_VALUE</code> 的 <code>LinkedBlockingQueue</code>（无界队列）</li></ul></li><li><p><code>CachedThreadPool</code>：核心线程数为0，最大线程数为Integer.MAX_VALUE</p><ul><li>使用容量为0的<code>SynchronousQueue</code> （同步队列）</li><li>相当于设置核心线程池和等待队列永远是满</li></ul></li><li><p><code>ScheduledThreadPool</code>：核心线程数为自定义，最大线程数为Integer.MAX_VALUE</p><ul><li>使用容量为<code>Integer.MAX_VALUE</code>的<code>DelayedWorkQueue</code>（延迟阻塞队列）</li></ul></li></ul><p>不推荐使用内置线程池（都容易因为创建大量线程/堆积大量请求导致OOM），应该通过ThreadPoolExecutor构造函数明确线程池运行规则创建</p><h3 id="常用的workqueue" tabindex="-1"><a class="header-anchor" href="#常用的workqueue"><span>常用的workQueue</span></a></h3><p>如果当前运行的线程数量达到核心线程数，新任务会被存放在队列中</p><ul><li>无界队列（<code>LinkedBlockingQueue</code>)：最大线程数Integer.MAX_VALUE</li><li>同步队列（<code>SynchronousQueue</code>）：最大线程数Integer.MAX_VALUE <ul><li>没有容量，不存储元素，用于保证如果有空闲线程则使用，否则创建新线程</li></ul></li><li>延迟阻塞队列（<code>DelayedWorkQueue</code>）： <ul><li>用于定时任务，按照执行时间升序来排列，底层实现结构为堆</li><li>自动扩充队列大小（每次扩容为原来的1/2），最大扩容到<code>Integer.MAX_VALUE</code></li><li>ScheduledThreadPool和SingleThreadScheduledExecutor</li></ul></li></ul><h3 id="饱和策略" tabindex="-1"><a class="header-anchor" href="#饱和策略"><span>饱和策略</span></a></h3><p><code>ThreadPoolExecutor.</code></p><ul><li><code>AbortPolicy</code>：拒绝任务，抛出异常<code>RejectedExecutionException</code></li><li><code>CallerRunsPolicy</code>：将任务回退给调用者主线程执行</li><li><code>DiscardPolicy</code>：不处理，直接丢弃</li><li><code>DiscardOldestPolicy</code>：丢弃最早的未处理的任务请求（抛弃workQueue里面等待最久的一个线程，然后把拒绝任务加到workQueue）</li></ul><h3 id="处理任务流程" tabindex="-1"><a class="header-anchor" href="#处理任务流程"><span>处理任务流程</span></a></h3><p>核心线程数是否已满</p><ul><li>创建</li><li>队列是否已满 <ul><li>加入队列</li><li>最大线程数是否已满 <ul><li>创建</li><li>饱和策略</li></ul></li></ul></li></ul><h2 id="threadlocal" tabindex="-1"><a class="header-anchor" href="#threadlocal"><span>ThreadLocal</span></a></h2><p>作用：线程的专属本地变量</p><h3 id="实现原理" tabindex="-1"><a class="header-anchor" href="#实现原理"><span>实现原理</span></a></h3><ul><li>Thread <ul><li>包含属性：ThreadLocalMap：<code>ThreadLocal&lt;?&gt; key, Object value</code></li><li>ThreadLocalMap 是ThreadLocal的静态内部类</li></ul></li></ul><p>使用：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> count <span class="token operator">=</span> <span class="token class-name">ThreadLocal</span><span class="token punctuation">.</span><span class="token function">withInitial</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
count<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="内存泄漏的原因" tabindex="-1"><a class="header-anchor" href="#内存泄漏的原因"><span>内存泄漏的原因</span></a></h3><p>key是弱引用，value是强引用，可能出现key被清理掉，value不会被清理掉</p><p>使用完 <code>ThreadLocal</code>方法后最好手动调用<code>remove()</code>方法</p><h2 id="future" tabindex="-1"><a class="header-anchor" href="#future"><span>Future</span></a></h2><p>Future是一个接口，核心思想是异步调用子线程来执行任务</p><p>FutureTask是具体的实现类</p><ul><li>实现了Future接口、Runnable接口</li><li>封装了实现Callable接口的对象（作为构造参数） <ul><li>如果传的是Runnable接口实现对象，会转换为Callable实现对象</li></ul></li></ul><p><code>ExecutorService.execute（Runnable task）</code></p><p><code>ExecutorService.submit（Runnable task）</code></p><p>主线程<code>FutureTask.get()</code></p><h3 id="callable和runnable有什么区别" tabindex="-1"><a class="header-anchor" href="#callable和runnable有什么区别"><span>Callable和Runnable有什么区别</span></a></h3><table><thead><tr><th style="text-align:left;">区别</th><th style="text-align:left;">Callable</th><th style="text-align:left;">Runnable</th></tr></thead><tbody><tr><td style="text-align:left;">返回值</td><td style="text-align:left;">有</td><td style="text-align:left;">无</td></tr><tr><td style="text-align:left;">异常处理</td><td style="text-align:left;">可以抛出异常</td><td style="text-align:left;">不能显示抛出异常在外面进行处理</td></tr></tbody></table><h3 id="execute和submit有什么区别" tabindex="-1"><a class="header-anchor" href="#execute和submit有什么区别"><span>execute和submit有什么区别</span></a></h3><table><thead><tr><th style="text-align:left;">区别</th><th style="text-align:left;">submit</th><th style="text-align:left;">execute</th></tr></thead><tbody><tr><td style="text-align:left;">返回值</td><td style="text-align:left;">提交需要返回值的任务，返回一个 <code>Future</code> 对象</td><td style="text-align:left;">无，提交不需要返回值的任务</td></tr><tr><td style="text-align:left;">异常处理</td><td style="text-align:left;">可以抛出异常</td><td style="text-align:left;">不能显示抛出异常在外面进行处理</td></tr></tbody></table><h3 id="shutdown和shutdownnow的区别" tabindex="-1"><a class="header-anchor" href="#shutdown和shutdownnow的区别"><span>shutdown和shutdownNow的区别</span></a></h3><ul><li>shutdown：不接受新任务，已有任务继续执行</li><li>shutdownNow：结束正在运行任务，返回等待队列的List</li></ul><h2 id="aqs" tabindex="-1"><a class="header-anchor" href="#aqs"><span>AQS</span></a></h2><p>抽象队列同步器，是一个抽象类，用来构建锁和同步器</p><p>比如：</p><ul><li><code>ReentrantLock</code></li><li><code>Semaphore</code></li><li><code>SynchronousQueue</code></li></ul><h3 id="实现原理-1" tabindex="-1"><a class="header-anchor" href="#实现原理-1"><span>实现原理</span></a></h3><p>为请求资源的线程分配共享资源、然后锁定资源，用队列管理使用资源和等待资源的线程</p><ul><li><p>CLH队列锁：虚拟的双向队列</p><ul><li>队列中的每个节点表示一个线程，存储： <ul><li>线程的引用</li><li>状态</li><li>prev</li><li>next</li></ul></li></ul></li><li><p>使用成员变量<code>private volatile int state;</code> 记录同步状态</p></li><li><p>方法：</p><ul><li><code>getState</code></li><li><code>setState</code></li><li><code>compareAndSetState</code></li></ul></li></ul><h3 id="reentrantlock-1" tabindex="-1"><a class="header-anchor" href="#reentrantlock-1"><span>ReentrantLock</span></a></h3><ul><li><code>state</code> 初始值为 0，表示未锁定状态，一个线程可以获取锁</li><li>A 线程 <code>lock()</code> 时，调用 <code>tryAcquire()</code> ，如果获取到锁： <code>state+1</code> ，独占该锁</li><li>A 线程调用 <code>unlock()</code> 直到 <code>state=0</code>才释放锁 <ul><li>这里到直到0是指 <code>unlock()</code> 可能需要调用多次：A 线程可以重复获取此锁，每次<code>state++</code></li><li>所以 <code>ReentrantLock</code> 可重入的实现表现为再次获取<code>state++</code></li></ul></li></ul><h3 id="semaphore" tabindex="-1"><a class="header-anchor" href="#semaphore"><span>Semaphore</span></a></h3><p>用于控制同时访问特定资源的线程数量（permits）</p><p>应用：单机限流；实际项目中推荐使用 Redis +Lua 做限流</p><p>Semaphore是共享锁的一种实现，默认构造 AQS 的 <code>state</code> 值为 <code>permits</code></p><ul><li><p><code>acquire</code>：</p><ul><li><code>state &gt; 0</code> 时，可以尝试获取，使用CAS 操作尝试修改 <code>state--</code> ；失败则进入阻塞队列，挂起线程</li><li><code>state &lt; 0</code> 时，无法获取资源，创建一个 Node 节点加入阻塞队列，挂起当前线程。</li></ul></li><li><p><code>release</code>：</p><ul><li>尝试释放，使用CAS 操作尝试修改 <code>state++</code></li><li>释放成功后会唤醒同步队列中的一个线程，回到上面<code>acquire</code>第一种情况</li></ul></li></ul><h3 id="countdownlatch" tabindex="-1"><a class="header-anchor" href="#countdownlatch"><span>CountDownLatch</span></a></h3><p>阻塞执行 <code>count</code> 个线程，直到全部线程任务执行完毕</p><p>应用场景：多线程读取多个文件处理</p><p>CountDownLatch共享锁的一种实现，默认构造 AQS 的 <code>state</code> 值为 <code>count</code></p>`,100),i=[s];function o(c,d){return a(),l("div",null,i)}const u=e(t,[["render",o],["__file","7. 并发.html.vue"]]),h=JSON.parse(`{"path":"/backend/java/7.%20%E5%B9%B6%E5%8F%91.html","title":"并发","lang":"zh-CN","frontmatter":{"title":"并发","order":7,"copyright":"<a href=\\"https://creativecommons.org/licenses/by-nc/4.0/\\">CC BY-NC 4.0协议</a>","description":"基础 现在的 Java 线程的本质其实就是操作系统的线程；new Thread().start()创建线程 线程模型： 一对一：在 Windows 和 Linux 等主流操作系统中Java采用的模型 一对多 多对多 从 JVM 的角度来说一下线程和进程之间的关系 线程共享的进程的如下资源： 堆（字符串常量池）：存放几乎所有对象 方法区：存放已加载的类信...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/KKBlog/backend/java/7.%20%E5%B9%B6%E5%8F%91.html"}],["meta",{"property":"og:site_name","content":"KK's Blog"}],["meta",{"property":"og:title","content":"并发"}],["meta",{"property":"og:description","content":"基础 现在的 Java 线程的本质其实就是操作系统的线程；new Thread().start()创建线程 线程模型： 一对一：在 Windows 和 Linux 等主流操作系统中Java采用的模型 一对多 多对多 从 JVM 的角度来说一下线程和进程之间的关系 线程共享的进程的如下资源： 堆（字符串常量池）：存放几乎所有对象 方法区：存放已加载的类信..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-14T07:00:16.000Z"}],["meta",{"property":"article:author","content":"KK"}],["meta",{"property":"article:modified_time","content":"2024-05-14T07:00:16.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"并发\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-05-14T07:00:16.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"KK\\",\\"url\\":\\"https://github.com/Nikki-Gu\\"}]}"]]},"headers":[{"level":2,"title":"基础","slug":"基础","link":"#基础","children":[{"level":3,"title":"从 JVM 的角度来说一下线程和进程之间的关系","slug":"从-jvm-的角度来说一下线程和进程之间的关系","link":"#从-jvm-的角度来说一下线程和进程之间的关系","children":[]},{"level":3,"title":"多线程安全问题","slug":"多线程安全问题","link":"#多线程安全问题","children":[]},{"level":3,"title":"start和run的区别","slug":"start和run的区别","link":"#start和run的区别","children":[]},{"level":3,"title":"sleep和wait方法区别","slug":"sleep和wait方法区别","link":"#sleep和wait方法区别","children":[]}]},{"level":2,"title":"volatile关键字","slug":"volatile关键字","link":"#volatile关键字","children":[]},{"level":2,"title":"锁","slug":"锁","link":"#锁","children":[{"level":3,"title":"悲观锁/独占锁","slug":"悲观锁-独占锁","link":"#悲观锁-独占锁","children":[]},{"level":3,"title":"乐观锁","slug":"乐观锁","link":"#乐观锁","children":[]},{"level":3,"title":"synchronized关键字","slug":"synchronized关键字","link":"#synchronized关键字","children":[]},{"level":3,"title":"ReentrantLock","slug":"reentrantlock","link":"#reentrantlock","children":[]}]},{"level":2,"title":"线程池","slug":"线程池","link":"#线程池","children":[{"level":3,"title":"创建","slug":"创建","link":"#创建","children":[]},{"level":3,"title":"常用的workQueue","slug":"常用的workqueue","link":"#常用的workqueue","children":[]},{"level":3,"title":"饱和策略","slug":"饱和策略","link":"#饱和策略","children":[]},{"level":3,"title":"处理任务流程","slug":"处理任务流程","link":"#处理任务流程","children":[]}]},{"level":2,"title":"ThreadLocal","slug":"threadlocal","link":"#threadlocal","children":[{"level":3,"title":"实现原理","slug":"实现原理","link":"#实现原理","children":[]},{"level":3,"title":"内存泄漏的原因","slug":"内存泄漏的原因","link":"#内存泄漏的原因","children":[]}]},{"level":2,"title":"Future","slug":"future","link":"#future","children":[{"level":3,"title":"Callable和Runnable有什么区别","slug":"callable和runnable有什么区别","link":"#callable和runnable有什么区别","children":[]},{"level":3,"title":"execute和submit有什么区别","slug":"execute和submit有什么区别","link":"#execute和submit有什么区别","children":[]},{"level":3,"title":"shutdown和shutdownNow的区别","slug":"shutdown和shutdownnow的区别","link":"#shutdown和shutdownnow的区别","children":[]}]},{"level":2,"title":"AQS","slug":"aqs","link":"#aqs","children":[{"level":3,"title":"实现原理","slug":"实现原理-1","link":"#实现原理-1","children":[]},{"level":3,"title":"ReentrantLock","slug":"reentrantlock-1","link":"#reentrantlock-1","children":[]},{"level":3,"title":"Semaphore","slug":"semaphore","link":"#semaphore","children":[]},{"level":3,"title":"CountDownLatch","slug":"countdownlatch","link":"#countdownlatch","children":[]}]}],"git":{"createdTime":1715670016000,"updatedTime":1715670016000,"contributors":[{"name":"Nikki-Gu","email":"394632208@qq.com","commits":1}]},"readingTime":{"minutes":8.39,"words":2517},"filePathRelative":"backend/java/7. 并发.md","localizedDate":"2024年5月14日","autoDesc":true}`);export{u as comp,h as data};
