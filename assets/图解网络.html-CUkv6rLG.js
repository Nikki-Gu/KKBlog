import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,o as t,d as p}from"./app-Bt_ElD8L.js";const l={},c=p('<h3 id="url请求过程发生了什么" tabindex="-1"><a class="header-anchor" href="#url请求过程发生了什么"><span>URL请求过程发生了什么</span></a></h3><p>传输层协议通过端口号来区分不同的应用服务，浏览器（客户端）这边使用随机端口号，目标服务器一般使用默认端口，比如HTTP的80和HTTPS的443。</p><p>如果服务器提供了多个HTTP服务，域名不同，IP地址相同，端口号相同，怎么区分不同服务呢？</p><blockquote><p>这时候就需要用到HTTP请求头里面的Host字段来指定请求的具体服务</p><p>所以Host字段实现了对虚拟主机的支持，所谓虚拟主机就是多个服务器共用一台主机，但外部看上去像是不同的服务器主机提供的服务</p></blockquote><p>网卡是什么</p><blockquote><p>将数字信息转换为电信号在网络上发送的硬件设备，需要网卡驱动操作系统才能控制网卡。</p><p>网卡驱动获取网络包之后，会将其<strong>复制</strong>到网卡内的缓存区中，接着会在其<strong>开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列FCS</strong>。</p></blockquote><p>如果客户端有多个网卡，选择哪个作为IP数据包的源地址呢？</p><blockquote><p>每个IP地址对应一个网卡，每个网卡通常连接到不同的网络或子网上。如果客户端主机具有多个网卡（IP地址），需要根据目标地址来选择合适的网卡（IP地址）。</p><p>具体来说，会根据目标地址和路由表规则来选择（路由匹配）</p><p>目标地址和子网掩码进行与运算得到目标子网地址，如果和路由表的Destination相同，就使用这个IP地址作为源IP地址。（理论上来讲，会选择离目标网络地址更近的网卡）</p></blockquote><p>已经知道源IP地址和目的IP地址，最开始是发送给哪个MAC地址？</p><blockquote><p>主机使用子网掩码分别计算目标地址和源IP地址的的网络地址，如果相同则说明在同一网络段，直接通过ARP协议获取目标MAC地址，发送</p><p>不相同说明不在同一网络段，填入路由器的MAC地址（先通过ARP协议获取路由器的MAC地址，填入MAC头部然后发送给路由器）</p></blockquote><p>交换机做什么</p><blockquote><p>通过FCS检验数据，无误的话放入缓冲区，在MAC 地址表中查询接收方MAC地址对应的端口并发送，如果找不到就广播</p><p>交换机MAC地址表存放网线端口和对应连接的MAC地址</p><p><strong>交换机的端口不具有 MAC 地址</strong>，只会原样转发数据</p></blockquote><p>路由器和交换机的区别</p><blockquote><ul><li><strong>路由器</strong>是基于 IP 设计的，俗称<strong>三层</strong>网络设备，路由器的各个端口都具有 MAC 地址和 IP 地址；</li><li><strong>交换机</strong>是基于以太网设计的，俗称<strong>二层</strong>网络设备，交换机的端口不具有 MAC 地址。</li></ul></blockquote><p>路由器做什么</p><blockquote><p>检查 MAC 头部中的<strong>接收方 MAC 地址</strong>是否为自己，是则接收，否则丢弃</p><p>接收后拆包MAC头部，丢弃</p><p>路由器通过路由表的网关列判断是否找到目标IP：</p><ul><li>为空：找到，直接ARP协议找目标IP的MAC地址，生成MAC头部并发送</li><li>不为空：继续转发到下一个网关，生成MAC头部并发送</li></ul></blockquote><p>网关是什么</p><blockquote><p>网关是一个抽象概念，具体实现有路由器、交换机、防火墙。</p></blockquote><h2 id="tcp" tabindex="-1"><a class="header-anchor" href="#tcp"><span>TCP</span></a></h2><blockquote><p>什么是TCP，什么是连接</p></blockquote><p>TCP 是<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议。</p><p>连接：客户端与服务端达成如下消息的共识：</p><ul><li><strong>Socket</strong>：由 IP 地址和端口号组成</li><li><strong>序列号</strong>：用来解决乱序问题等</li><li><strong>窗口大小</strong>：用来做流量控制</li></ul><blockquote><p>怎么确定一个TCP连接</p></blockquote><p>TCP四元组：</p><ul><li>源地址</li><li>源端口</li><li>目的地址</li><li>目的端口</li></ul><blockquote><p>如何理解TCP面向字节流，UDP面向报文？TCP粘包问题是什么</p></blockquote><p>消息边界：一条有含义的消息的长度</p><p><strong>每个 UDP 报文就是一个用户消息的边界</strong>，而TCP消息可能会被拆分（取决于发送窗口、拥塞窗口以及当前发送缓冲区的大小等条件），无法确定消息边界</p><p>TCP粘包问题：当两个消息的某个部分内容被分到同一个 TCP 报文时，这时接收方不知道消息的边界的话，无法读出有效的消息。</p><p>解决：应用层协议定义消息边界，比如HTTP</p><ul><li>特殊字符：HTTP 通过设置回车符、换行符作为 HTTP 消息头和消息体的边界</li><li>自定义消息结构</li></ul><blockquote><p>没有 accept，能建立 TCP 连接吗？</p></blockquote><p>能，accept是建立连接之后的系统调用，可以从全连接队列里面获取文件描述符</p><blockquote><p>TCP三次连接能携带数据吗？</p></blockquote><p><strong>第三次握手是可以携带数据的，前两次握手是不可以携带数据的</strong></p><blockquote><p>TCP的超时重传机制？</p></blockquote><ol><li>使用RTO超时重传时间，超过RTO就重发</li><li>超时间隔加倍：遇到一次超时重传，RTO加倍</li></ol><p><code>RTT</code>是包的往返时间，用来计算RTO：采用RTT，对RTT加权平均；采样RTT的波动范围；</p><blockquote><p>TCP的快速重传</p></blockquote><p>解决超时周期可能很长的问题，快速重传是数据驱动的：</p><ol><li>收到三个相同的 ACK 报文时，即使定时器没过期（没到达RTO）也会立刻重传丢失的报文段</li></ol><blockquote><p>SACK是什么？</p></blockquote><p>重传的一种确认方法，用于实现只重传丢失的数据。因为快速重传不知道具体丢失了哪部分的数据，该重传一个还是多个。</p><p>在TCP头部添加一个SACK字段，<strong>将已收到的数据的信息发送给「发送方」</strong>，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以<strong>只重传丢失的数据</strong>。</p><blockquote><p>为什么要用滑动窗口？</p></blockquote><p>TCP 通过让接收方指明希望从发送方接收的数据大小（窗口大小）来进行流量控制。</p><p>不用滑动窗口就是一问一答，每次发送方只能发送一个数据，等到应答ACK了之后，才能继续发送下一个数据</p><p>滑动窗口可以记录还没有收到确认的已发送报文，收到确认之后移除</p><p>所以滑动窗口大小是无需等待确认应答，可以连续发送数据的最大值</p><ul><li>滑动窗口本质是缓存区</li><li>发送窗口 <code>swnd</code> 和接收窗口 <code>rwnd</code> 是约等于的关系：接收方有一个窗口用来接收数据，使用window字段告诉发送方自己的缓冲区可以接收多少数据，所以，发送方窗口的大小是由接收方的窗口大小来决定的</li><li>发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据。</li></ul><blockquote><p>为什么需要拥塞控制？</p></blockquote><p>**避免「发送方」的数据填满整个网络。**所以TCP使用「<strong>拥塞窗口</strong>」调节「发送方」所要发送数据的量</p><p><strong>拥塞窗口 cwnd</strong>是发送方维护的一个的状态变量，它会根据<strong>网络的拥塞程度动态变化的</strong>。</p><p>加入了拥塞窗口的概念后，此时发送窗口的值是<code>swnd = min(cwnd, rwnd)</code>，也就是拥塞窗口和接收窗口中的最小值。</p><blockquote><p>拥塞控制原则：</p></blockquote><p>拥塞窗口 <code>cwnd</code> 变化的规则：</p><ul><li>只要网络中没有出现拥塞，<code>cwnd</code> 就会增大；</li><li>但网络中出现了拥塞，<code>cwnd</code> 就减少；</li></ul><p>拥塞判断：只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是<strong>发生了超时重传，就会认为网络出现了拥塞。</strong></p><blockquote><p>拥塞控制算法有哪些？</p></blockquote><p>一般画图的都是假定拥塞窗口 <code>cwnd</code> 和发送窗口 <code>swnd</code> 相等，没有考虑接收窗口的大小，所以才会指数增长、线性增长</p><ul><li>慢启动： <ul><li><strong>当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。</strong></li><li>慢启动门限 <code>ssthresh</code> （slow start threshold）状态变量，当 <code>cwnd</code> &gt;= <code>ssthresh</code> 时，使用「拥塞避免算法」；一般来说 <code>ssthresh</code> 的大小是 <code>65535</code> 字节</li></ul></li><li>拥塞避免：<strong>每当收到一个 ACK 时，cwnd 增加 1/cwnd。</strong></li><li>拥塞发生：有数据包丢失需要重传时进入拥塞发生 <ul><li>使用超时重传：<code>ssthresh</code> 设为 <code>cwnd/2</code>；<code>cwnd</code> 重置为初始化值</li><li>使用快速重传：<code>ssthresh = cwnd</code> ；<code>cwnd = cwnd/2</code> ；进入快速恢复</li></ul></li><li>快速恢复</li></ul><h3 id="udp" tabindex="-1"><a class="header-anchor" href="#udp"><span>UDP</span></a></h3><p>头结构：4个字节，每个字段16位</p><ul><li>目标端口</li><li>源端口</li><li>包长度：UDP报文总长度，该字段保存了 UDP 首部的长度跟数据的长度之和</li><li>校验和：校验和是为了提供可靠的 UDP 首部和数据而设计，防止收到在网络传输中受损的 UDP 包</li></ul><blockquote><p>TCP和UDP可以用同一个端口号吗？</p></blockquote><p>可以的，端口号是用来区分应用层的应用的，TCP和UDP是传输层的选择，接收到IP数据包拆开后获取到IP头部信息中就有协议，可以确定是TCP还是UDP</p><h2 id="ip" tabindex="-1"><a class="header-anchor" href="#ip"><span>IP</span></a></h2><p><strong>MAC 的作用则是实现「直连」的两个设备之间通信，而 IP 则负责在「没有直连」的两个网络之间进行通信传输。</strong></p><p>在网络中数据包传输中也是如此，<strong>源IP地址和目标IP地址在传输过程中是不会变化的（前提：没有使用 NAT 网络），只有源 MAC 地址和目标 MAC 一直在变化。</strong></p><p>IP 地址根据网卡来配置</p><p>IP 地址分类成了 5 种类型，分别是 A 类、B 类、C 类、D 类、E 类。</p><p>解析IP地址：不管是路由器还是主机解析到一个 IP 地址时候，我们判断其 IP 地址的首位是否为 0，为 0 则为 A 类地址，那么就能很快的找出网络地址和主机地址。</p><p>主机号全0标识网络；主机号全1标识广播</p><p>无分类地址方案</p><p>表示形式 <code>a.b.c.d/x</code>，其中 <code>/x</code> 表示前 x 位属于<strong>网络号</strong>， x 的范围是 <code>0 ~ 32</code></p><p>通过网络号/子网掩码来区分网络地址和主机地址</p><p>子网掩码还可以将主机地址分为两个部分：</p><ul><li><p>子网网络地址：子网号</p></li><li><p>子网主机地址：</p></li><li><p>未做子网划分的 ip 地址：网络地址＋主机地址</p></li><li><p>做子网划分后的 ip 地址：网络地址＋（子网网络地址＋子网主机地址）</p></li></ul>',79),i=[c];function n(s,r){return t(),e("div",null,i)}const u=o(l,[["render",n],["__file","图解网络.html.vue"]]),P=JSON.parse(`{"path":"/backend/cs-base/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C.html","title":"图解网络总结","lang":"zh-CN","frontmatter":{"title":"图解网络总结","order":2,"copyright":"<a href=\\"https://creativecommons.org/licenses/by-nc/4.0/\\">CC BY-NC 4.0协议</a>","description":"URL请求过程发生了什么 传输层协议通过端口号来区分不同的应用服务，浏览器（客户端）这边使用随机端口号，目标服务器一般使用默认端口，比如HTTP的80和HTTPS的443。 如果服务器提供了多个HTTP服务，域名不同，IP地址相同，端口号相同，怎么区分不同服务呢？ 这时候就需要用到HTTP请求头里面的Host字段来指定请求的具体服务 所以Host字段实...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/KKBlog/backend/cs-base/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C.html"}],["meta",{"property":"og:site_name","content":"KK's Blog"}],["meta",{"property":"og:title","content":"图解网络总结"}],["meta",{"property":"og:description","content":"URL请求过程发生了什么 传输层协议通过端口号来区分不同的应用服务，浏览器（客户端）这边使用随机端口号，目标服务器一般使用默认端口，比如HTTP的80和HTTPS的443。 如果服务器提供了多个HTTP服务，域名不同，IP地址相同，端口号相同，怎么区分不同服务呢？ 这时候就需要用到HTTP请求头里面的Host字段来指定请求的具体服务 所以Host字段实..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-14T07:00:16.000Z"}],["meta",{"property":"article:author","content":"KK"}],["meta",{"property":"article:modified_time","content":"2024-05-14T07:00:16.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"图解网络总结\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-05-14T07:00:16.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"KK\\",\\"url\\":\\"https://github.com/Nikki-Gu\\"}]}"]]},"headers":[{"level":3,"title":"URL请求过程发生了什么","slug":"url请求过程发生了什么","link":"#url请求过程发生了什么","children":[]},{"level":2,"title":"TCP","slug":"tcp","link":"#tcp","children":[{"level":3,"title":"UDP","slug":"udp","link":"#udp","children":[]}]},{"level":2,"title":"IP","slug":"ip","link":"#ip","children":[]}],"git":{"createdTime":1715670016000,"updatedTime":1715670016000,"contributors":[{"name":"Nikki-Gu","email":"394632208@qq.com","commits":1}]},"readingTime":{"minutes":9.23,"words":2770},"filePathRelative":"backend/cs-base/计算机网络/图解网络.md","localizedDate":"2024年5月14日","autoDesc":true}`);export{u as comp,P as data};
