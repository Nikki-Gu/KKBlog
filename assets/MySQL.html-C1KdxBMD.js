import{_ as l}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,o as i,d as t}from"./app-xI3EPUdd.js";const a={},d=t('<h2 id="字段类型" tabindex="-1"><a class="header-anchor" href="#字段类型"><span>字段类型</span></a></h2><p>变长字段有哪些？</p><blockquote><p>varchar、text、blob、json、varbinary</p></blockquote><p>UNSIGNED属性：将正整数的存储上限提高一倍</p><p>char和varchar的区别：</p><ul><li>CHAR(M) 和 VARCHAR(M) 的 M ：代表能保存最大字符数</li><li>char是定长的（存储时会填充空格以达到指定长度）：适合定长数据</li><li>varchar是不定长的（用额外的字节记录字符串长度，实际存储的就是字符串，不填充）：适合不定长数据 <ul><li>在内存中操作时会分配固定M大小的内存块来保存值</li></ul></li></ul><p>NULL和&#39; &#39;的区别：</p><ul><li>NULL是不确定的值，占用空间 <ul><li>聚合函数一般忽略NULL，COUNT（*）会统计NULL</li><li>查询 <code>NULL</code> 值时，必须使用 <code>IS NULL</code> 或 <code>IS NOT NULL</code> 来判断，不能使用比较运算符</li></ul></li><li>&#39; &#39;是空，不占用空间 <ul><li>可以使用比较运算符来比较</li></ul></li></ul><p>Boolean类型： 没有专门的布尔类型，使用TINYINT(1)， 可以存储0和1</p><h2 id="基础架构" tabindex="-1"><a class="header-anchor" href="#基础架构"><span>基础架构</span></a></h2><h3 id="两层" tabindex="-1"><a class="header-anchor" href="#两层"><span>两层</span></a></h3><ul><li>Server层：包括连接器、分析器、优化器、执行器</li><li>存储引擎层：插件式存储引擎ENGINES：InnoDB（5.5.5之后默认）、MyISAM、Memory <ul><li>存储引擎是基于表的而不是基于数据库的（每个表可以使用不同存储引擎）</li><li>MyISAM和InnoDB的区别 TODO</li></ul></li></ul><h3 id="执行sql语句的过程" tabindex="-1"><a class="header-anchor" href="#执行sql语句的过程"><span>执行SQL语句的过程</span></a></h3><ul><li><p>连接器：</p><ul><li><p>TCP连接</p><ul><li>短连接和长连接，使用内存管理连接对象 <ul><li>怎么解决长连接占用内存的问题？定期断开长连接、客户端主动重置连接</li></ul></li></ul></li><li><p>登录、读取权限</p></li></ul></li><li><p>查询缓存：MySQL 8.0 版本后移除（更适合不经常更新的数据表的查询）</p></li><li><p>解析SQL：词法分析+语法分析</p></li><li><p>执行SQL：</p><ul><li><p>预处理：</p><ul><li>检查 SQL 查询语句中的表或者字段是否存在；</li><li>将 <code>select *</code> 中的 <code>*</code> 符号，扩展为表上的所有列；</li></ul></li><li><p>优化器：选择执行方案，主要是选择使用哪个索引（使用explain命令可以查看）</p><ul><li>选择查询代价小的索引</li></ul></li><li><p>执行器：调用存储引擎索引查询/全表扫描的接口；都是找到一条满足的数据就返回给Server（是否使用索引下推只是返回前是否多进行条件判断的区别）</p></li></ul></li></ul><h2 id="事务" tabindex="-1"><a class="header-anchor" href="#事务"><span>事务</span></a></h2><p>定义：逻辑上的一组操作，要么都执行，要么都不执行</p><p>关系型数据库事务都有ACID特性</p><h3 id="并发事务带来的问题" tabindex="-1"><a class="header-anchor" href="#并发事务带来的问题"><span>并发事务带来的问题</span></a></h3><ul><li><p>丢失修改：同时操作导致其中一个事务的修改结果丢失</p></li><li><p>脏读：读到未被持久化的脏数据（另一个事务处理中的数据）</p></li><li><p>不可重复读：一个事务多次读同一数据，结果不一致（另一个事务在delete/update，持续时间比读的这个事务短）</p></li><li><p>幻读：一个事务多次读同一范围内的数据，数据量增加（insert）</p></li></ul><h3 id="并发事务的控制方式" tabindex="-1"><a class="header-anchor" href="#并发事务的控制方式"><span>并发事务的控制方式</span></a></h3><ul><li><p>锁：悲观控制</p><ul><li><p>读写锁</p><ul><li>共享锁（S锁）：兼容</li><li>排他锁（X锁）：独占</li></ul><p>只有共享锁和共享锁兼容</p></li><li><p>锁的颗粒度（都包含上述两个读写锁）</p><ul><li>表级锁</li><li>行级锁</li></ul></li></ul></li><li><p>MVCC：多版本并发控制；乐观控制</p><ul><li>每个数据行维护多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本</li><li>快照读；写创建新版本数据</li><li>版本回收</li><li>具体实现：隐藏字段、ReadView、undolog</li></ul></li></ul><h3 id="隔离级别" tabindex="-1"><a class="header-anchor" href="#隔离级别"><span>隔离级别</span></a></h3><p>MySQL有四个隔离级别：</p><table><thead><tr><th>可以阻止的并发问题</th><th>丢失更新</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>Read Uncommitted</td><td>✔️</td><td>❌</td><td>❌</td><td>❌</td></tr><tr><td>Read Committed</td><td>✔️</td><td>✔️</td><td>❌</td><td>❌</td></tr><tr><td>Repeatable Read</td><td>✔️</td><td>✔️</td><td>✔️</td><td>❌</td></tr><tr><td>Serializable</td><td>✔️</td><td>✔️</td><td>✔️</td><td>✔️</td></tr></tbody></table><h3 id="innodb对隔离级别的实现" tabindex="-1"><a class="header-anchor" href="#innodb对隔离级别的实现"><span>InnoDB对隔离级别的实现</span></a></h3><p>基于锁和MVCC共同实现</p><ul><li><p>Read Uncommitted：不允许同时写（写X锁），读数据不需要获取锁</p></li><li><p>Read Committed：</p><ul><li>使用MVCC实现：<strong>在「每个读取语句执行前」都会重新生成一个 Read View</strong><ul><li>通过ReadView解决了脏读问题</li><li>会出现不可重复读问题：事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务</li><li>快照读和当前读的结果是一样的，都是最新的</li></ul></li></ul></li><li><p>Repeatable Read：</p><ul><li>快照读（普通 select 语句）使用MVCC解决幻读：<strong>「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View</strong><ul><li>事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</li></ul></li><li>当前读（select ... for update 等语句）使用Next-Key Lock加锁解决幻读： <ul><li>其他事务无法在 next-key lock 锁范围内插入，会阻塞</li></ul></li></ul></li><li><p>Serializable：锁</p></li></ul><h4 id="readview和隐藏字段" tabindex="-1"><a class="header-anchor" href="#readview和隐藏字段"><span>ReadView和隐藏字段</span></a></h4><p><strong>通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）</strong></p><p>ReadView四个重要的字段：</p><ul><li>creator_trx_id：创建这一条readview的事务的id</li><li>m_ids：创建 Read View 时，当前数据库中「活跃事务」（<strong>启动了但还没提交）的</strong>事务 id 列表**</li><li>min_trx_id：m_ids中最小值</li><li>max_trx_id：下一个创建的事务的id值，全局事务中最大的事务 id 值 + 1</li></ul><p>记录的两个隐藏字段：</p><ul><li>trx_id：上一个修改的事务的id</li><li>roll_pointer：指向旧版本记录的指针；形成版本链</li></ul><p>可见原则：</p><p>一个事务去访问记录的时候，除了自己更新的记录总是可见之外，它可见的记录满足如下条件，</p><p><code>trx_id &lt; min_trx_id</code> 或 <code>(min_trx_id &lt;= trx_id &lt;= max_trx_id) &amp;&amp; trx_id not in m_ids </code></p><p>不满足的记录对该事务都不可见，需要按照roll_pointer的版本链去找可见的版本记录</p>',37),r=[d];function n(p,o){return i(),e("div",null,r)}const h=l(a,[["render",n],["__file","MySQL.html.vue"]]),u=JSON.parse(`{"path":"/backend/database/MySQL.html","title":"MySQL","lang":"zh-CN","frontmatter":{"title":"MySQL","order":4,"copyright":"<a href=\\"https://creativecommons.org/licenses/by-nc/4.0/\\">CC BY-NC 4.0协议</a>","description":"字段类型 变长字段有哪些？ varchar、text、blob、json、varbinary UNSIGNED属性：将正整数的存储上限提高一倍 char和varchar的区别： CHAR(M) 和 VARCHAR(M) 的 M ：代表能保存最大字符数 char是定长的（存储时会填充空格以达到指定长度）：适合定长数据 varchar是不定长的（用额外的字...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/KKBlog/backend/database/MySQL.html"}],["meta",{"property":"og:site_name","content":"KK's Blog"}],["meta",{"property":"og:title","content":"MySQL"}],["meta",{"property":"og:description","content":"字段类型 变长字段有哪些？ varchar、text、blob、json、varbinary UNSIGNED属性：将正整数的存储上限提高一倍 char和varchar的区别： CHAR(M) 和 VARCHAR(M) 的 M ：代表能保存最大字符数 char是定长的（存储时会填充空格以达到指定长度）：适合定长数据 varchar是不定长的（用额外的字..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-14T07:00:16.000Z"}],["meta",{"property":"article:author","content":"KK"}],["meta",{"property":"article:modified_time","content":"2024-05-14T07:00:16.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"MySQL\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-05-14T07:00:16.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"KK\\",\\"url\\":\\"https://github.com/Nikki-Gu\\"}]}"]]},"headers":[{"level":2,"title":"字段类型","slug":"字段类型","link":"#字段类型","children":[]},{"level":2,"title":"基础架构","slug":"基础架构","link":"#基础架构","children":[{"level":3,"title":"两层","slug":"两层","link":"#两层","children":[]},{"level":3,"title":"执行SQL语句的过程","slug":"执行sql语句的过程","link":"#执行sql语句的过程","children":[]}]},{"level":2,"title":"事务","slug":"事务","link":"#事务","children":[{"level":3,"title":"并发事务带来的问题","slug":"并发事务带来的问题","link":"#并发事务带来的问题","children":[]},{"level":3,"title":"并发事务的控制方式","slug":"并发事务的控制方式","link":"#并发事务的控制方式","children":[]},{"level":3,"title":"隔离级别","slug":"隔离级别","link":"#隔离级别","children":[]},{"level":3,"title":"InnoDB对隔离级别的实现","slug":"innodb对隔离级别的实现","link":"#innodb对隔离级别的实现","children":[]}]}],"git":{"createdTime":1715670016000,"updatedTime":1715670016000,"contributors":[{"name":"Nikki-Gu","email":"394632208@qq.com","commits":1}]},"readingTime":{"minutes":4.9,"words":1471},"filePathRelative":"backend/database/MySQL.md","localizedDate":"2024年5月14日","autoDesc":true}`);export{h as comp,u as data};
