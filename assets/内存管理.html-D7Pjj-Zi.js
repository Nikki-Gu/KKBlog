import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as l,o as t,d as p}from"./app-hJoYqN43.js";const i={},a=p('<p>虚拟内存的作用：</p><ol><li><p>可以使得进程运行内存超过无力内存大小，利用硬盘swap区域存储没有使用的内存，利用了局部性原理</p></li><li><p>每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的，解决了多进程之间地址冲突的问题</p><blockquote><p>并不保证进程之间的内存隔离，进程还是有可能访问其他进程的物理内存</p><p>非法指针、缓冲区溢出</p></blockquote></li></ol><h2 id="分段" tabindex="-1"><a class="header-anchor" href="#分段"><span>分段</span></a></h2><p>将程序按照逻辑分段，按照实际需求分配内存</p><p>分段机制把程序的虚拟地址分成四个段（栈、堆、数据、代码），每个段对应一个基地址和段界限</p><p>分段机制中虚拟地址是通过<strong>段表</strong>和物理地址进行映射的：</p><ul><li>虚拟地址由两部分组成，<strong>段选择因子</strong>和<strong>段内偏移量</strong></li><li>从段选择因子里面取段号，到段表里面去查询物理内存空间里面的起始地址</li><li>物理内存地址 = 起始地址+段内偏移量</li></ul><p>存在的问题：</p><ol><li><p>外部内存碎片</p><p>分段按照实际需求分配内存，不会出现内部内存碎片，但是段的长度不固定，所以有外部内存碎片问题</p><p>解决「外部内存碎片」的问题：<strong>内存交换</strong>，在硬盘中划分出来一块swap空间专门用于内存交换，将内存读出到swap空间，然后读入的时候紧接着分配的空间装载</p></li><li><p>内存交换效率低</p><p>如果内存交换的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿</p></li></ol><h2 id="分页" tabindex="-1"><a class="header-anchor" href="#分页"><span>分页</span></a></h2><p>总结：分页可以结局外部内存碎片的问题，可以按需加载，换页方便（固定大小），但是使用单级页表太大，所以使用多级页表，使用多级页表查找效率比较低，所以使用TLB（页表缓存、转址旁路缓存、快表）</p><h3 id="定义" tabindex="-1"><a class="header-anchor" href="#定义"><span>定义</span></a></h3><p>把虚拟和物理内存划分为大小相同的页，在 Linux 下，每一页的大小为 <code>4KB</code></p><p>分段机制中虚拟地址是通过<strong>页表</strong>和物理地址进行映射的：</p><ul><li>虚拟地址由两部分组成，<strong>页号</strong>和<strong>页内偏移量</strong></li><li>用页号去页表里面查询物理页号（物理内存基地址）</li><li>物理内存地址 = 基地址 + 页内偏移量</li></ul><p>存在内部内存碎片</p><p>按需加载：在加载程序的时候，如果分配的虚拟内存没有访问是不会映射到物理内存的。</p><p>只有在访问已分配的虚拟地址空间的时候，操作系统通过查找页表，发现虚拟内存对应的页没有在物理内存中，就会触发<strong>缺页中断</strong>，进行内存分配，再建立虚拟内存和物理内存之间的映射关系。</p><h3 id="多级页表" tabindex="-1"><a class="header-anchor" href="#多级页表"><span>多级页表</span></a></h3><p>页表很大：页表一定要覆盖全部虚拟地址空间（也就是进程想要存的东西，一定是真的存下来，有物理地址可以寻址的）</p><p>具体单级页表大小计算：如果是32位的系统，虚拟地址空间大小为4GB，每个进程都要4GB的虚拟地址空间，每个页的大小是4KB，则每个进程都需要有2^20（1M = 4GB / 4KB）个页表项，每个页表项使用4个字节来粗处，则需要4MB的内存来存储页表</p><p>用多级页表解决</p><ul><li>总的是1MB个页表项，如果按照每个二级页表有1K条来划分，则需要1K个二级页表</li><li>创建一个一级页表映射二级页表数目，则一级页表有1K项</li><li>这样只有1K项，每一项4B，一共4KB就覆盖了整个虚拟地址空间</li><li>二级页表按需创建，因为显然对于大多数程序来说，其使用到的空间远未达到 4GB，所以大部分页表项都是空的不需要分配</li></ul><p>64 位的系统，两级分页不够了，使用四级目录</p><blockquote><p>虚拟地址空间大小：取决于CPU处理能力能处理多少位的数据</p><p>物理内存大小：取决于硬件</p><p>32位处理器一般理论寻址空间2<sup>32Bytes，可以分配2</sup>32个地址，每个地址存储一个字节数据所以是2^32B</p><p>2^32 = 2^10（K）* 2^10(M) * 2^10(G) * 4</p><p>1K = 2^10 = 1024</p><p>1M = 2^20 = 1024 * 1024</p><p>1G = 2^30 = 1024 * 1024 * 1024</p><p>1 TB = 1024 GB</p></blockquote><h2 id="段页式" tabindex="-1"><a class="header-anchor" href="#段页式"><span>段页式</span></a></h2><p>虚拟地址 = <strong>段号 + 段内页号 + 页内位移</strong></p><p>段页式地址变换中要得到物理地址须经过三次内存访问：</p><ul><li>第一次访问段表，得到页表起始地址；</li><li>第二次访问页表，得到物理页号；</li><li>第三次将物理页号与页内位移组合，得到物理地址。</li></ul><h2 id="linux的内存分布" tabindex="-1"><a class="header-anchor" href="#linux的内存分布"><span>Linux的内存分布</span></a></h2><p>虚拟地址空间的内部分为<strong>内核空间和用户空间</strong>两部分</p><p>其中用户态的分布（由低到高）：代码段、全局变量、BSS、函数栈、堆内存、映射区。</p><p>32位，一共4G虚拟地址空间：1G内核空间+3G用户空间</p><p>64位：内核在上面128T，用户在下面128T，其他未定义（只使用了48位来表示虚拟地址）</p><p><strong>虽然每个进程有自己的虚拟内存空间，但是每个虚拟内存中的内核地址，关联的都是相同的物理内存</strong></p><h2 id="内存分配" tabindex="-1"><a class="header-anchor" href="#内存分配"><span>内存分配</span></a></h2><p><strong>缺页中断</strong>：访问到没有被分配的虚拟内存，CPU产生缺页中断，进程会从用户态切换到内核态，并将缺页中断交给内核的 Page Fault Handler （缺页中断函数）处理。</p><p>Page Fault Handler （缺页中断函数）会去看是否有空闲的物理内存：</p><ul><li>如果有，就直接分配物理内存，并建立虚拟内存与物理内存之间的映射关系。</li><li>如果没有空闲的物理内存，那么内核就会开始进行内存回收 <ul><li>回收后满足要求，分配</li><li>空闲的物理内存仍然不满足要求，OOM</li></ul></li></ul><h2 id="内存回收" tabindex="-1"><a class="header-anchor" href="#内存回收"><span>内存回收</span></a></h2><p>有两种方式，分别是线程异步的后台回收和阻塞的直接回收：</p><ul><li><p><strong>后台内存回收</strong>（kswapd）：在物理内存紧张（空闲内存低于阈值）的时候，会唤醒 kswapd 内核线程来回收内存，这个回收内存的过程<strong>异步</strong>的，不会阻塞进程的执行。</p></li><li><p><strong>直接内存回收</strong>（direct reclaim）：如果后台异步回收跟不上进程内存申请的速度，就会开始直接回收，这个回收内存的过程是<strong>同步</strong>的，会阻塞进程的执行。</p><p>内存不足的时候进行直接内存回收</p></li></ul><blockquote><p>Swap 换入换出的是什么类型的内存？</p><ol><li>内核缓存的文件数据，因为都有对应的磁盘文件， 直接写回到对应的文件，释放内存</li><li>匿名页：进程的堆、栈数据等，它们是没有实际载体；需要写到磁盘的 Swap 分区中</li></ol></blockquote><h3 id="_4gb-物理内存的机器上-申请-8gb-内存-会怎么样" tabindex="-1"><a class="header-anchor" href="#_4gb-物理内存的机器上-申请-8gb-内存-会怎么样"><span>4GB 物理内存的机器上，申请 8GB 内存，会怎么样？</span></a></h3><p>32位：不行，最多只能申请3GB内存</p><p>64位：<code>128T = 128 * 1024GB &gt;&gt; 4GB</code>，可以申请</p><p>申请后具体能否使用要看操作系统有没有开启 Swap 机制：</p><ul><li>如果没有开启 Swap 机制，程序就会直接 OOM；</li><li>如果有开启 Swap 机制，程序可以正常运行。</li></ul><p>64位机器能申请128T内存吗？如果只有2GB物理内存，大概率不行，因为页表是存储在物理内存上的，申请过程中物理内存放不下了就无法申请，但是如果开启了swap机制，就可以</p>',49),n=[a];function o(r,s){return t(),l("div",null,n)}const d=e(i,[["render",o],["__file","内存管理.html.vue"]]),g=JSON.parse(`{"path":"/backend/cs-base/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html","title":"内存管理","lang":"zh-CN","frontmatter":{"title":"内存管理","order":3,"copyright":"<a href=\\"https://creativecommons.org/licenses/by-nc/4.0/\\">CC BY-NC 4.0协议</a>","description":"虚拟内存的作用： 可以使得进程运行内存超过无力内存大小，利用硬盘swap区域存储没有使用的内存，利用了局部性原理 每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的，解决了多进程之间地址冲突的问题 并不保证进程之间的内存隔离，进程还是有可能访问其他进程的物理内存 非法指针、缓冲区溢出 分段 将程序按照逻辑分段，按照实际需求分配内存 分段机...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/KKBlog/backend/cs-base/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"}],["meta",{"property":"og:site_name","content":"KK's Blog"}],["meta",{"property":"og:title","content":"内存管理"}],["meta",{"property":"og:description","content":"虚拟内存的作用： 可以使得进程运行内存超过无力内存大小，利用硬盘swap区域存储没有使用的内存，利用了局部性原理 每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的，解决了多进程之间地址冲突的问题 并不保证进程之间的内存隔离，进程还是有可能访问其他进程的物理内存 非法指针、缓冲区溢出 分段 将程序按照逻辑分段，按照实际需求分配内存 分段机..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-14T07:39:54.000Z"}],["meta",{"property":"article:author","content":"KK"}],["meta",{"property":"article:modified_time","content":"2024-05-14T07:39:54.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"内存管理\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-05-14T07:39:54.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"KK\\",\\"url\\":\\"https://github.com/Nikki-Gu\\"}]}"]]},"headers":[{"level":2,"title":"分段","slug":"分段","link":"#分段","children":[]},{"level":2,"title":"分页","slug":"分页","link":"#分页","children":[{"level":3,"title":"定义","slug":"定义","link":"#定义","children":[]},{"level":3,"title":"多级页表","slug":"多级页表","link":"#多级页表","children":[]}]},{"level":2,"title":"段页式","slug":"段页式","link":"#段页式","children":[]},{"level":2,"title":"Linux的内存分布","slug":"linux的内存分布","link":"#linux的内存分布","children":[]},{"level":2,"title":"内存分配","slug":"内存分配","link":"#内存分配","children":[]},{"level":2,"title":"内存回收","slug":"内存回收","link":"#内存回收","children":[{"level":3,"title":"4GB 物理内存的机器上，申请 8GB 内存，会怎么样？","slug":"_4gb-物理内存的机器上-申请-8gb-内存-会怎么样","link":"#_4gb-物理内存的机器上-申请-8gb-内存-会怎么样","children":[]}]}],"git":{"createdTime":1715670016000,"updatedTime":1715672394000,"contributors":[{"name":"Nikki-Gu","email":"394632208@qq.com","commits":2}]},"readingTime":{"minutes":6.69,"words":2006},"filePathRelative":"backend/cs-base/操作系统/内存管理.md","localizedDate":"2024年5月14日","autoDesc":true}`);export{d as comp,g as data};
