import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,o as s,d as t}from"./app-4Yi0tegr.js";const e={},p=t(`<h2 id="进程线程基础知识" tabindex="-1"><a class="header-anchor" href="#进程线程基础知识"><span>进程线程基础知识</span></a></h2><h3 id="进程和线程的区别" tabindex="-1"><a class="header-anchor" href="#进程和线程的区别"><span>进程和线程的区别</span></a></h3><p>进程可以包含多个线程，进程是资源分配的最小单位，线程是CPU调度的最小单位</p><p>进程中的多个线程共享进程资源（打开的文件、占用的内存）</p><p>进程之间相互独立，也因此会消耗更多的计算资源；同一个进程中的线程容易相互影响</p><p>线程执行开销小，但不利于资源的管理和保护</p><h3 id="线程的类型" tabindex="-1"><a class="header-anchor" href="#线程的类型"><span>线程的类型</span></a></h3><p>CPU密集型线程：分配N+1大小的线程池</p><p>IO密集型线程：分配2N大小的线程池</p><h3 id="线程模型" tabindex="-1"><a class="header-anchor" href="#线程模型"><span>线程模型？</span></a></h3><h3 id="单核cpu上多个线程效率一定会高吗" tabindex="-1"><a class="header-anchor" href="#单核cpu上多个线程效率一定会高吗"><span>单核CPU上多个线程效率一定会高吗？</span></a></h3><p>任务是 CPU 密集型：开很多线程会影响效率</p><p>IO密集型：提高效率</p><h3 id="pcb进程控制块是什么" tabindex="-1"><a class="header-anchor" href="#pcb进程控制块是什么"><span>PCB进程控制块是什么</span></a></h3><p>(<strong>Process Control Block</strong>)</p><p>用来管理和跟踪进程的数据结构（让我想到Java中的Class对于类的管理）</p><h3 id="进程的5种状态" tabindex="-1"><a class="header-anchor" href="#进程的5种状态"><span>进程的5种状态</span></a></h3><ul><li>new</li><li>ready</li><li>running</li><li>waiting</li><li>terminated</li></ul><h3 id="java线程的6种状态" tabindex="-1"><a class="header-anchor" href="#java线程的6种状态"><span>Java线程的6种状态</span></a></h3><ul><li>new</li><li>runnable(ready + running)</li><li>timed_waiting：会自动返回runnable的等待</li><li>waiting：释放锁等待</li><li>blocked：未获取到锁</li><li>terminated</li></ul><h3 id="僵尸进程" tabindex="-1"><a class="header-anchor" href="#僵尸进程"><span>僵尸进程</span></a></h3><p>僵尸进程：子进程终止，但是父进程没有调用wait/waitpid来获取子进程状态信息并释放资源，导致子进程的PCB仍然存在</p><p>ps：死了但没完全死；垃圾没清理干净</p><p>如何查看：top命令，zombie值表示僵尸进程数量</p><p>解决方法：父进程应该及时调用wait/waitpid获取信息释放资源</p><h3 id="孤儿进程" tabindex="-1"><a class="header-anchor" href="#孤儿进程"><span>孤儿进程</span></a></h3><p>孤儿进程：子进程还在，但是父进程在调用wait/waitpid前终止了；</p><p>解决方式：为了避免孤儿进程占用系统资源，操作系统会将孤儿进程的父进程设置为 init 进程（进程号为 1），由 init 进程来回收孤儿进程的资源。</p><h3 id="并发与并行的区别" tabindex="-1"><a class="header-anchor" href="#并发与并行的区别"><span>并发与并行的区别</span></a></h3><p>并发：同时段执行</p><p>并行：同时执行</p><h2 id="进程间通信" tabindex="-1"><a class="header-anchor" href="#进程间通信"><span>进程间通信</span></a></h2><ul><li><p>同一台主机上进行进程间通信：管道、消息队列、共享内存、信号量和信号</p></li><li><p>跨主机进程通信：Socket</p></li><li><p>同步通信：管道、消息队列、共享内存、信号量和Socket</p></li><li><p>异步通信：信号</p></li></ul><h3 id="管道" tabindex="-1"><a class="header-anchor" href="#管道"><span>管道</span></a></h3><p>｜<code>int pipe(int fd[2])</code></p><p>数据写入内核空间，是内核里面的一段缓存；单向的，先进先出原则；</p><p>存在用户态与内核态之间的数据拷贝开销</p><h3 id="消息队列" tabindex="-1"><a class="header-anchor" href="#消息队列"><span>消息队列</span></a></h3><p>消息队列是内核里面的消息链表；存在用户态与内核态之间的数据拷贝开销</p><h3 id="共享内存" tabindex="-1"><a class="header-anchor" href="#共享内存"><span>共享内存</span></a></h3><p>每个进程拿出一块虚拟地址空间来，映射到相同的物理内存中</p><h3 id="信号量" tabindex="-1"><a class="header-anchor" href="#信号量"><span>信号量</span></a></h3><p>信号量的作用是防止多进程竞争共享资源，保护共享资源</p><p>信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，不是直接用来通信的</p><p>信号量初始化为 <code>1</code>，就代表着是<strong>互斥信号量</strong>，它可以保证共享内存在任何时刻只有一个进程在访问，保护资源</p><p>信号初始化为 <code>0</code>，就代表着是<strong>同步信号量</strong>，它可以保证进程的执行顺序（一个进程先生成数据，再V操作，一个进程先P操作，再读取数据）</p><h3 id="信号" tabindex="-1"><a class="header-anchor" href="#信号"><span>信号</span></a></h3><p>在 Linux 操作系统中kil命令可以给指定PID进程发送信号</p><p><code>kill -9 1050</code> ，表示给 PID 为 1050 的进程发送 <code>SIGKILL</code> 信号，用来立即结束该进程；</p><p><code>kill -l</code> 命令，查看所有的信号</p><p>信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令）。</p><p>信号是进程间通信机制中<strong>唯一的异步通信机制</strong></p><p>处理信号方式：</p><ol><li>Linux 对每种信号都规定了默认操作</li><li>可以自己给信号定义一个信号处理函数（这样中断到内核之后，内核转到调用用户态的处理函数，这个处理函数再调用内核进行处理，然后再回到主控制程序）</li><li>忽略信号</li></ol><h3 id="socket" tabindex="-1"><a class="header-anchor" href="#socket"><span>Socket</span></a></h3><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">socket</span><span class="token punctuation">(</span><span class="token keyword">int</span> domain<span class="token punctuation">,</span> <span class="token keyword">int</span> type<span class="token punctuation">,</span> <span class="token keyword">int</span> protocal<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>参数解释：</p><ul><li>domain 参数用来指定协议族 <ul><li>AF_INET： 用于 IPV4</li><li>AF_INET6 ：用于 IPV6</li><li>AF_LOCAL/AF_UNIX ：用于本机</li></ul></li><li>type 参数用来指定通信特性 <ul><li>SOCK_STREAM：字节流，TCP</li><li>SOCK_DGRAM：数据报，UDP</li><li>SOCK_RAW：原始套接字？</li></ul></li><li>protocal：废弃</li></ul><p>流程：</p><p>TCP：socket、bind、listen、accept</p><p>UDP：socket、bind</p><p>本地：socket，本地字节流 socket 和 本地数据报 socket 在 bind 的时候，不像 TCP 和 UDP 要绑定 IP 地址和端口，而是<strong>绑定一个本地文件</strong></p><h2 id="线程通信" tabindex="-1"><a class="header-anchor" href="#线程通信"><span>线程通信</span></a></h2><p>线程间是共享进程资源的，可以直接通过共享变量来通信</p><p>所以线程间通信指的不是线程之间传输数据的方式，而是多线程如何解决竞争共享资源的问题，也就是如何进行互斥和同步</p><h3 id="互斥和同步" tabindex="-1"><a class="header-anchor" href="#互斥和同步"><span>互斥和同步</span></a></h3><p>临界区：访问共享资源的代码片段</p><p>同步：两个及以上的操作的执行顺序</p><p>互斥：两个及以上的操作不能在同一时刻执行</p><h3 id="互斥和同步的实现" tabindex="-1"><a class="header-anchor" href="#互斥和同步的实现"><span>互斥和同步的实现</span></a></h3><ul><li>锁：实现互斥；基于test-and-set原子指令实现加锁、解锁操作； <ul><li>忙等待锁（自旋锁）：获取不到锁的时候一直循环忙等，一直占用CPU周期，除非被抢占或者别的进程/线程释放锁</li><li>无等待锁：等待队列；没获取到锁的时候，就把当前线程放入到锁的等待队列，然后执行调度程序，把 CPU 让给其他线程执行</li></ul></li><li>信号量：实现互斥和同步；基于P、V原子指令实现 <ul><li>信号量用来表示资源的数量，对应一个整型变量sem</li><li>P操作：sem = sem - 1之后如果sem &lt; 0，阻塞等待</li><li>V操作：sem = sem + 1之后如果sem &lt;= 0， 唤醒等待的进程/线程</li></ul></li></ul><p>经典同步问题：</p><ul><li><p>哲学家就餐问题：对哲学家进行编号，奇数和偶数优先拿的顺序不同（先左后右、先右后左）</p></li><li><p>读者写者问题：</p><ul><li>读者优先：只要有读者在读，后续的读者都可以可以进入读者队列读，读者队列为空才能写</li><li>写者优先：只要有写者出现，就可以写</li><li>公平：读者有读者队列，如果有写者出现，阻塞后续的读者进入读者队列</li></ul></li></ul><h2 id="死锁" tabindex="-1"><a class="header-anchor" href="#死锁"><span>死锁</span></a></h2><p>定义：两个及以上的进程，因为资源竞争，导致互相等待，然后无限期阻塞的情况</p><h3 id="模拟死锁的代码" tabindex="-1"><a class="header-anchor" href="#模拟死锁的代码"><span>模拟死锁的代码</span></a></h3><p>线程A和B，需要资源resource1和resource2，分别占有其中一个，等待另外一个</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DeadLockExample</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Object</span> resource1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Object</span> resource2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>resource1<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;get resource1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;waiting resource2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>resource2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;get resource2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">&quot;线程1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>resource2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;get resource2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;waiting resource1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>resource1<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;get resource1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">&quot;线程2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="产生死锁的四个必要条件" tabindex="-1"><a class="header-anchor" href="#产生死锁的四个必要条件"><span>产生死锁的四个必要条件：</span></a></h3><ol><li>互斥</li><li>占有并等待</li><li>非抢占：资源不能被抢占</li><li>循环等待</li></ol><h3 id="解决死锁的方法" tabindex="-1"><a class="header-anchor" href="#解决死锁的方法"><span>解决死锁的方法</span></a></h3><h4 id="预防-静态分配和层次分配策略" tabindex="-1"><a class="header-anchor" href="#预防-静态分配和层次分配策略"><span>预防（静态分配和层次分配策略）</span></a></h4><ol><li>预防占用并等待：使用静态分配策略，一个进程必须在执行前就申请到它所需要的全部资源；降低了资源利用率（占有后很久不使用）</li><li>预防循环等待：层次分配策略（一个进程得到某一次的一个资源后，它只能再申请较高一层的资源；当一个进程要释放某层的一个资源时，必须先释放所占用的较高层的资源）</li><li>按顺序分配资源</li></ol><h4 id="避免-保证安全状态-银行家算法" tabindex="-1"><a class="header-anchor" href="#避免-保证安全状态-银行家算法"><span>避免（保证安全状态，银行家算法）</span></a></h4><p>保证系统处在安全状态（安全状态是指所有进程能在有限时间内得到需要的全部资源）</p><p>Dijkstra 的银行家算法：当进程申请使用资源的时候，进行如下两步</p><ul><li>试探分配</li><li>安全性算法：判断分配后是否处于安全状态 <ul><li>分配作废</li><li>真实分配</li></ul></li></ul><h4 id="检测-进程-资源分配图、拓扑排序" tabindex="-1"><a class="header-anchor" href="#检测-进程-资源分配图、拓扑排序"><span>检测（进程-资源分配图、拓扑排序）</span></a></h4><p>不加限制，只是定时监测是否出现死锁，然后再解除死锁</p><p>通过进程-资源分配图进行检测</p><ul><li>无环路：安全</li><li>有环路 <ul><li>单个资源：死锁</li><li>多个资源： <ul><li>去找 <strong>既不阻塞又非独立的进程</strong>，然后消除边，看是否能在优先时间消除边</li></ul></li></ul></li></ul><h4 id="解除" tabindex="-1"><a class="header-anchor" href="#解除"><span>解除</span></a></h4><ul><li>立刻结束所有进程并重启</li><li>撤销所有进程，重新运行</li><li>逐个撤销死锁进程，回收资源直到死锁解除</li><li>抢占资源再分配</li></ul>`,93),l=[p];function c(i,o){return s(),a("div",null,l)}const d=n(e,[["render",c],["__file","进程管理.html.vue"]]),k=JSON.parse(`{"path":"/backend/cs-base/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.html","title":"进程管理","lang":"zh-CN","frontmatter":{"title":"进程管理","order":2,"copyright":"<a href=\\"https://creativecommons.org/licenses/by-nc/4.0/\\">CC BY-NC 4.0协议</a>","description":"进程线程基础知识 进程和线程的区别 进程可以包含多个线程，进程是资源分配的最小单位，线程是CPU调度的最小单位 进程中的多个线程共享进程资源（打开的文件、占用的内存） 进程之间相互独立，也因此会消耗更多的计算资源；同一个进程中的线程容易相互影响 线程执行开销小，但不利于资源的管理和保护 线程的类型 CPU密集型线程：分配N+1大小的线程池 IO密集型线...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/KKBlog/backend/cs-base/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86.html"}],["meta",{"property":"og:site_name","content":"KK's Blog"}],["meta",{"property":"og:title","content":"进程管理"}],["meta",{"property":"og:description","content":"进程线程基础知识 进程和线程的区别 进程可以包含多个线程，进程是资源分配的最小单位，线程是CPU调度的最小单位 进程中的多个线程共享进程资源（打开的文件、占用的内存） 进程之间相互独立，也因此会消耗更多的计算资源；同一个进程中的线程容易相互影响 线程执行开销小，但不利于资源的管理和保护 线程的类型 CPU密集型线程：分配N+1大小的线程池 IO密集型线..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-14T07:00:16.000Z"}],["meta",{"property":"article:author","content":"KK"}],["meta",{"property":"article:modified_time","content":"2024-05-14T07:00:16.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"进程管理\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-05-14T07:00:16.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"KK\\",\\"url\\":\\"https://github.com/Nikki-Gu\\"}]}"]]},"headers":[{"level":2,"title":"进程线程基础知识","slug":"进程线程基础知识","link":"#进程线程基础知识","children":[{"level":3,"title":"进程和线程的区别","slug":"进程和线程的区别","link":"#进程和线程的区别","children":[]},{"level":3,"title":"线程的类型","slug":"线程的类型","link":"#线程的类型","children":[]},{"level":3,"title":"线程模型？","slug":"线程模型","link":"#线程模型","children":[]},{"level":3,"title":"单核CPU上多个线程效率一定会高吗？","slug":"单核cpu上多个线程效率一定会高吗","link":"#单核cpu上多个线程效率一定会高吗","children":[]},{"level":3,"title":"PCB进程控制块是什么","slug":"pcb进程控制块是什么","link":"#pcb进程控制块是什么","children":[]},{"level":3,"title":"进程的5种状态","slug":"进程的5种状态","link":"#进程的5种状态","children":[]},{"level":3,"title":"Java线程的6种状态","slug":"java线程的6种状态","link":"#java线程的6种状态","children":[]},{"level":3,"title":"僵尸进程","slug":"僵尸进程","link":"#僵尸进程","children":[]},{"level":3,"title":"孤儿进程","slug":"孤儿进程","link":"#孤儿进程","children":[]},{"level":3,"title":"并发与并行的区别","slug":"并发与并行的区别","link":"#并发与并行的区别","children":[]}]},{"level":2,"title":"进程间通信","slug":"进程间通信","link":"#进程间通信","children":[{"level":3,"title":"管道","slug":"管道","link":"#管道","children":[]},{"level":3,"title":"消息队列","slug":"消息队列","link":"#消息队列","children":[]},{"level":3,"title":"共享内存","slug":"共享内存","link":"#共享内存","children":[]},{"level":3,"title":"信号量","slug":"信号量","link":"#信号量","children":[]},{"level":3,"title":"信号","slug":"信号","link":"#信号","children":[]},{"level":3,"title":"Socket","slug":"socket","link":"#socket","children":[]}]},{"level":2,"title":"线程通信","slug":"线程通信","link":"#线程通信","children":[{"level":3,"title":"互斥和同步","slug":"互斥和同步","link":"#互斥和同步","children":[]},{"level":3,"title":"互斥和同步的实现","slug":"互斥和同步的实现","link":"#互斥和同步的实现","children":[]}]},{"level":2,"title":"死锁","slug":"死锁","link":"#死锁","children":[{"level":3,"title":"模拟死锁的代码","slug":"模拟死锁的代码","link":"#模拟死锁的代码","children":[]},{"level":3,"title":"产生死锁的四个必要条件：","slug":"产生死锁的四个必要条件","link":"#产生死锁的四个必要条件","children":[]},{"level":3,"title":"解决死锁的方法","slug":"解决死锁的方法","link":"#解决死锁的方法","children":[]}]}],"git":{"createdTime":1715670016000,"updatedTime":1715670016000,"contributors":[{"name":"Nikki-Gu","email":"394632208@qq.com","commits":1}]},"readingTime":{"minutes":7.49,"words":2247},"filePathRelative":"backend/cs-base/操作系统/进程管理.md","localizedDate":"2024年5月14日","autoDesc":true}`);export{d as comp,k as data};
