import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,o as s,d as t}from"./app-xI3EPUdd.js";const e={},p=t(`<h1 id="图论" tabindex="-1"><a class="header-anchor" href="#图论"><span>图论</span></a></h1><h2 id="图的基础知识" tabindex="-1"><a class="header-anchor" href="#图的基础知识"><span>图的基础知识</span></a></h2><h4 id="存储方式" tabindex="-1"><a class="header-anchor" href="#存储方式"><span>存储方式</span></a></h4><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 邻接表</span>
<span class="token comment">// 有向图 graph[x] 存储 x 的所有邻居节点</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> graph<span class="token punctuation">;</span>
<span class="token comment">// 有向加权图 graph[x] 存储 x 的所有邻居节点以及对应的权重</span>
<span class="token class-name">List</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">[</span><span class="token punctuation">]</span> graph<span class="token punctuation">;</span>

<span class="token comment">// 邻接矩阵</span>
<span class="token comment">// 有向图 matrix[x][y] 记录 x 是否有一条指向 y 的边</span>
<span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">;</span>
<span class="token comment">// 有向加权图 matrix[x][y] 记录 x 指向 y 的边的权重，0 表示不相邻</span>
<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>邻接表 <ul><li>占用空间少</li><li>无法快速判断两个节点是否相邻</li></ul></li><li>度 <ul><li>每个节点相连的边的条数</li><li>有向图的边有方向：入度和出度</li></ul></li><li>无向图 = 双向图 <ul><li>如果无向图中的节点 <code>x</code> 和 <code>y</code>有边：</li><li>把 <code>matrix[x][y]</code> 和 <code>matrix[y][x]</code> 都变成 <code>true</code></li><li>在 <code>x</code> 的邻居列表里添加 <code>y</code>，同时在 <code>y</code> 的邻居列表里添加 <code>x</code></li></ul></li></ul><p>DAG有向无环图</p><h2 id="基础题目" tabindex="-1"><a class="header-anchor" href="#基础题目"><span>基础题目</span></a></h2><h4 id="_1-所有可能的路径" tabindex="-1"><a class="header-anchor" href="#_1-所有可能的路径"><span>1. 所有可能的路径</span></a></h4><p>可以完全和回溯一样来做，也可以按照图的遍历来做。两者的区别在于对于选择/状态的改变在for循环外/内</p><p>其实我感觉两者出发的逻辑完全不同，只是代码相似，完全可以不放在一起考虑，只需要考虑区别即可，不需要去找共同点</p><h4 id="_2-图的环检测-课程表canfinish-编译器的循环引用检测" tabindex="-1"><a class="header-anchor" href="#_2-图的环检测-课程表canfinish-编译器的循环引用检测"><span>2. 图的环检测（课程表canFinish）（编译器的循环引用检测）</span></a></h4><p>第一步：构建图</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>  <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> graph <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token punctuation">[</span>numCourses<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numCourses<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 需要先new 数组里面的对象</span>
      graph<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> edge <span class="token operator">:</span> prerequisites<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      graph<span class="token punctuation">[</span>edge<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>edge<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第二步：for循环将所有节点都作为起点调用一次 DFS 搜索算法</p><div class="hint-container tip"><p class="hint-container-title">提示</p><p>注意图中并不是所有节点都相连，所以要用一个 for 循环将所有节点都作为起点调用一次 DFS 搜索算法</p><ul><li>hasCycle 用于记录是否已经监测到有环，有的话直接返回，不用继续遍历</li><li>visited 是用来剪枝的 <ul><li>对于访问过的节点，肯定已经对它的所有子节点都遍历过了，判断过从它开始遍历是否有环了，不需要重复判断</li><li>所以可以在 for 循环中只对!visited[s]进行traverse</li><li>最重要的剪枝是traverse函数里面，如果visited[s]直接返回</li></ul></li><li>onPath是用来判断是否有环的 <ul><li>需要放在for循环外面，否则会漏掉最开始的节点，没法逻辑统一</li></ul></li></ul></div><h4 id="_3-拓扑排序-拓扑排序-图是否有环-后序遍历-课程表2" tabindex="-1"><a class="header-anchor" href="#_3-拓扑排序-拓扑排序-图是否有环-后序遍历-课程表2"><span>3. 拓扑排序（拓扑排序=图是否有环+后序遍历）（课程表2）</span></a></h4><p>有向无环图，拉平，箭头方向一致</p><p>基于2.添加上后序遍历即可</p><h4 id="_4-最小生成树" tabindex="-1"><a class="header-anchor" href="#_4-最小生成树"><span>4. 最小生成树</span></a></h4><p>Kruskal算法</p><p>Prim算法</p><h4 id="_5-最短路径" tabindex="-1"><a class="header-anchor" href="#_5-最短路径"><span>5. 最短路径</span></a></h4><p>Dijkstra算法</p><h4 id="_6-名流问题" tabindex="-1"><a class="header-anchor" href="#_6-名流问题"><span>6. 名流问题</span></a></h4><p>名人节点的出度为 0，入度为 <code>n - 1</code></p><p>最优解法：时间复杂度为 O(N)，空间复杂度为 O(1)</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">int</span> <span class="token function">findCelebrity</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 先假设 cand 是名人</span>
    <span class="token keyword">int</span> cand <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> other <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> other <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> other<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">knows</span><span class="token punctuation">(</span>other<span class="token punctuation">,</span> cand<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">knows</span><span class="token punctuation">(</span>cand<span class="token punctuation">,</span> other<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// cand 不可能是名人，假设 other 是名人</span>
            cand <span class="token operator">=</span> other<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 现在的 cand 是排除的最后结果，验证</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> other <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> other <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> other<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>cand <span class="token operator">==</span> other<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">knows</span><span class="token punctuation">(</span>other<span class="token punctuation">,</span> cand<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">knows</span><span class="token punctuation">(</span>cand<span class="token punctuation">,</span> other<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> cand<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="纯考验图的dfs" tabindex="-1"><a class="header-anchor" href="#纯考验图的dfs"><span>纯考验图的DFS</span></a></h3><h4 id="_1-岛屿问题" tabindex="-1"><a class="header-anchor" href="#_1-岛屿问题"><span>1. 岛屿问题</span></a></h4><p>floodfill算法</p><h4 id="_2-腐烂的橘子" tabindex="-1"><a class="header-anchor" href="#_2-腐烂的橘子"><span>2. 腐烂的橘子</span></a></h4><p>BFS，用队列实现</p><h4 id="_5-单词搜索" tabindex="-1"><a class="header-anchor" href="#_5-单词搜索"><span>5. 单词搜索</span></a></h4><p>和岛屿问题框架相似</p><p>使用visited数组防止重复</p>`,35),o=[p];function c(i,l){return s(),a("div",null,o)}const d=n(e,[["render",c],["__file","2. 图论.html.vue"]]),k=JSON.parse(`{"path":"/algorithm/Hot100/2.%20%E5%9B%BE%E8%AE%BA.html","title":"图论","lang":"zh-CN","frontmatter":{"title":"图论","order":6,"copyright":"<a href=\\"https://creativecommons.org/licenses/by-nc/4.0/\\">CC BY-NC 4.0协议</a>","description":"图论 图的基础知识 存储方式 邻接表 占用空间少 无法快速判断两个节点是否相邻 度 每个节点相连的边的条数 有向图的边有方向：入度和出度 无向图 = 双向图 如果无向图中的节点 x 和 y有边： 把 matrix[x][y] 和 matrix[y][x] 都变成 true 在 x 的邻居列表里添加 y，同时在 y 的邻居列表里添加 x DAG有向无环图...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/KKBlog/algorithm/Hot100/2.%20%E5%9B%BE%E8%AE%BA.html"}],["meta",{"property":"og:site_name","content":"KK's Blog"}],["meta",{"property":"og:title","content":"图论"}],["meta",{"property":"og:description","content":"图论 图的基础知识 存储方式 邻接表 占用空间少 无法快速判断两个节点是否相邻 度 每个节点相连的边的条数 有向图的边有方向：入度和出度 无向图 = 双向图 如果无向图中的节点 x 和 y有边： 把 matrix[x][y] 和 matrix[y][x] 都变成 true 在 x 的邻居列表里添加 y，同时在 y 的邻居列表里添加 x DAG有向无环图..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-14T07:39:54.000Z"}],["meta",{"property":"article:author","content":"KK"}],["meta",{"property":"article:modified_time","content":"2024-05-14T07:39:54.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"图论\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-05-14T07:39:54.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"KK\\",\\"url\\":\\"https://github.com/Nikki-Gu\\"}]}"]]},"headers":[{"level":2,"title":"图的基础知识","slug":"图的基础知识","link":"#图的基础知识","children":[]},{"level":2,"title":"基础题目","slug":"基础题目","link":"#基础题目","children":[{"level":3,"title":"纯考验图的DFS","slug":"纯考验图的dfs","link":"#纯考验图的dfs","children":[]}]}],"git":{"createdTime":1715670016000,"updatedTime":1715672394000,"contributors":[{"name":"Nikki-Gu","email":"394632208@qq.com","commits":2}]},"readingTime":{"minutes":2.93,"words":879},"filePathRelative":"algorithm/Hot100/2. 图论.md","localizedDate":"2024年5月14日","autoDesc":true}`);export{d as comp,k as data};
