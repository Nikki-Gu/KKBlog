import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as t,c as a,e as i}from"./app-ARawJAy0.js";const l={},o=i('<h1 id="锁的实现" tabindex="-1"><a class="header-anchor" href="#锁的实现"><span>锁的实现</span></a></h1><h2 id="互斥锁和自旋锁" tabindex="-1"><a class="header-anchor" href="#互斥锁和自旋锁"><span>互斥锁和自旋锁</span></a></h2><p>最基本最底层的两种锁，更高级的锁都会选择其中一个来实现，选择原则：</p><ul><li>被锁住的代码执行时间很短，应该选用自旋锁，否则使用互斥锁</li></ul><p>互斥锁和自旋锁的区别在于对于加锁失败后的处理方式不同：</p><ul><li><strong>互斥锁</strong>加锁失败后，线程阻塞并<strong>释放 CPU</strong> 给其他线程 <ul><li>由内核实现：加锁失败而阻塞，可以获取到锁之后唤醒线程获取锁</li><li>加锁失败的线程至少存在两次主动的上下文切换成本（还有被动的比如时间片用完了的切换）</li></ul></li><li><strong>自旋锁</strong>加锁失败后，线程会<strong>忙等待</strong>，直到它拿到锁 <ul><li>由CPU 提供的 <code>CAS</code> 函数（<em>Compare And Swap</em>）在用户态实现，不会主动产生线程上下文切换</li><li>单核非抢占调度器不可用，不然可能会一直忙等</li><li>自旋的时间和被锁住的代码执行的时间是成「正比」的关系</li></ul></li></ul><h2 id="读写锁" tabindex="-1"><a class="header-anchor" href="#读写锁"><span>读写锁</span></a></h2><p>定义</p><ul><li>写锁：互斥</li><li>读锁：共享</li></ul><p>不同实现</p><ul><li>读优先</li><li>写优先</li><li>公平：用队列把获取锁的线程排队，不管是写线程还是读线程都按照先进先出的原则加锁</li></ul><p>读写锁可以根据场景选择互斥锁和自旋锁其中的一个进行实现</p><h2 id="乐观锁和悲观锁" tabindex="-1"><a class="header-anchor" href="#乐观锁和悲观锁"><span>乐观锁和悲观锁</span></a></h2><p>悲观锁：假定冲突的概率很高，访问共享资源前先上锁；互斥锁、自旋锁、读写锁，都是属于悲观锁。</p><p>乐观锁：假定冲突的概率很低，先修改资源再验证是否有冲突需要处理</p>',15),n=[o];function r(s,c){return t(),a("div",null,n)}const h=e(l,[["render",r],["__file","锁的实现.html.vue"]]),m=JSON.parse('{"path":"/backend/cs-base/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0.html","title":"锁的实现","lang":"zh-CN","frontmatter":{"title":"锁的实现","order":6,"copyright":"<a href=\\"https://creativecommons.org/licenses/by-nc/4.0/\\">CC BY-NC 4.0协议</a>","description":"锁的实现 互斥锁和自旋锁 最基本最底层的两种锁，更高级的锁都会选择其中一个来实现，选择原则： 被锁住的代码执行时间很短，应该选用自旋锁，否则使用互斥锁 互斥锁和自旋锁的区别在于对于加锁失败后的处理方式不同： 互斥锁加锁失败后，线程阻塞并释放 CPU 给其他线程 由内核实现：加锁失败而阻塞，可以获取到锁之后唤醒线程获取锁 加锁失败的线程至少存在两次主动的...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/backend/cs-base/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0.html"}],["meta",{"property":"og:site_name","content":"文档演示"}],["meta",{"property":"og:title","content":"锁的实现"}],["meta",{"property":"og:description","content":"锁的实现 互斥锁和自旋锁 最基本最底层的两种锁，更高级的锁都会选择其中一个来实现，选择原则： 被锁住的代码执行时间很短，应该选用自旋锁，否则使用互斥锁 互斥锁和自旋锁的区别在于对于加锁失败后的处理方式不同： 互斥锁加锁失败后，线程阻塞并释放 CPU 给其他线程 由内核实现：加锁失败而阻塞，可以获取到锁之后唤醒线程获取锁 加锁失败的线程至少存在两次主动的..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-14T07:00:16.000Z"}],["meta",{"property":"article:author","content":"KK"}],["meta",{"property":"article:modified_time","content":"2024-05-14T07:00:16.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"锁的实现\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-05-14T07:00:16.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"KK\\"}]}"]]},"headers":[{"level":2,"title":"互斥锁和自旋锁","slug":"互斥锁和自旋锁","link":"#互斥锁和自旋锁","children":[]},{"level":2,"title":"读写锁","slug":"读写锁","link":"#读写锁","children":[]},{"level":2,"title":"乐观锁和悲观锁","slug":"乐观锁和悲观锁","link":"#乐观锁和悲观锁","children":[]}],"git":{"createdTime":1715670016000,"updatedTime":1715670016000,"contributors":[{"name":"Nikki-Gu","email":"394632208@qq.com","commits":1}]},"readingTime":{"minutes":1.52,"words":455},"filePathRelative":"backend/cs-base/操作系统/锁的实现.md","localizedDate":"2024年5月14日","autoDesc":true}');export{h as comp,m as data};
