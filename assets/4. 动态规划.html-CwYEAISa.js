import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as e,c as o,e as c,w as l,d as a,o as i,a as n,b as s}from"./app-D5166FK3.js";const u={},k=a('<h1 id="动态规划" tabindex="-1"><a class="header-anchor" href="#动态规划"><span>动态规划</span></a></h1><h2 id="_1-自底向上迭代的动态规划" tabindex="-1"><a class="header-anchor" href="#_1-自底向上迭代的动态规划"><span>1. 自底向上迭代的动态规划</span></a></h2><p>int[] dp = new int[length]</p><p>定义base case，使用状态转移方程填充dp数组</p><h3 id="一维" tabindex="-1"><a class="header-anchor" href="#一维"><span>一维</span></a></h3><h4 id="_1-爬楼梯" tabindex="-1"><a class="header-anchor" href="#_1-爬楼梯"><span>1. 爬楼梯</span></a></h4><p>要到达现在，上一步有两种选择，1或者2</p><p>base case: dp[0] = 1, dp[1] = 1;</p><h4 id="_2-最长递增子序列" tabindex="-1"><a class="header-anchor" href="#_2-最长递增子序列"><span>2. 最长递增子序列</span></a></h4><ul><li><p>注意dp数组的定义不是直接是结果，而是i为结尾的子序列的最大长度</p><ul><li>初始化：Arrays.fill(dp, 1);</li><li>需要两个for循环：外层遍历数组填充dp数组，内层遍历数组起始位置到当前要填充位置，如果存在小于当前位置元素，获取对应dp值（最大子序列长度）+ 1，尝试更新当前dp值</li></ul></li><li><p>遍历dp数组获取最大值</p></li></ul>',10),r=n("div",{class:"language-java line-numbers-mode","data-ext":"java","data-title":"java"},[n("pre",{class:"language-java"},[n("code",null,[n("span",{class:"token keyword"},"import"),s(),n("span",{class:"token import"},[n("span",{class:"token namespace"},[s("java"),n("span",{class:"token punctuation"},"."),s("util"),n("span",{class:"token punctuation"},".")]),n("span",{class:"token class-name"},"Arrays")]),n("span",{class:"token punctuation"},";"),s(`

`),n("span",{class:"token keyword"},"public"),s(),n("span",{class:"token keyword"},"class"),s(" didi_interview "),n("span",{class:"token punctuation"},"{"),s(`
    `),n("span",{class:"token keyword"},"public"),s(),n("span",{class:"token keyword"},"static"),s(),n("span",{class:"token keyword"},"void"),s(),n("span",{class:"token function"},"main"),n("span",{class:"token punctuation"},"("),n("span",{class:"token class-name"},"String"),n("span",{class:"token punctuation"},"["),n("span",{class:"token punctuation"},"]"),s(" args"),n("span",{class:"token punctuation"},")"),s(),n("span",{class:"token punctuation"},"{"),s(`
        `),n("span",{class:"token keyword"},"int"),n("span",{class:"token punctuation"},"["),n("span",{class:"token punctuation"},"]"),s(" nums "),n("span",{class:"token operator"},"="),s(),n("span",{class:"token keyword"},"new"),s(),n("span",{class:"token keyword"},"int"),n("span",{class:"token punctuation"},"["),n("span",{class:"token punctuation"},"]"),n("span",{class:"token punctuation"},"{"),n("span",{class:"token number"},"10"),n("span",{class:"token punctuation"},","),n("span",{class:"token number"},"9"),n("span",{class:"token punctuation"},","),n("span",{class:"token number"},"2"),n("span",{class:"token punctuation"},","),n("span",{class:"token number"},"5"),n("span",{class:"token punctuation"},","),n("span",{class:"token number"},"3"),n("span",{class:"token punctuation"},","),n("span",{class:"token number"},"7"),n("span",{class:"token punctuation"},","),n("span",{class:"token number"},"101"),n("span",{class:"token punctuation"},","),n("span",{class:"token number"},"18"),n("span",{class:"token punctuation"},"}"),n("span",{class:"token punctuation"},";"),s(`
        `),n("span",{class:"token class-name"},"System"),n("span",{class:"token punctuation"},"."),s("out"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"println"),n("span",{class:"token punctuation"},"("),n("span",{class:"token function"},"lengthOfLS"),n("span",{class:"token punctuation"},"("),s("nums"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),s(`
    `),n("span",{class:"token punctuation"},"}"),s(`
    `),n("span",{class:"token keyword"},"public"),s(),n("span",{class:"token keyword"},"static"),s(),n("span",{class:"token keyword"},"int"),s(),n("span",{class:"token function"},"lengthOfLS"),n("span",{class:"token punctuation"},"("),n("span",{class:"token keyword"},"int"),n("span",{class:"token punctuation"},"["),n("span",{class:"token punctuation"},"]"),s(" nums"),n("span",{class:"token punctuation"},")"),s(),n("span",{class:"token punctuation"},"{"),s(`
        `),n("span",{class:"token keyword"},"int"),n("span",{class:"token punctuation"},"["),n("span",{class:"token punctuation"},"]"),s(" dp "),n("span",{class:"token operator"},"="),s(),n("span",{class:"token keyword"},"new"),s(),n("span",{class:"token keyword"},"int"),n("span",{class:"token punctuation"},"["),s("nums"),n("span",{class:"token punctuation"},"."),s("length"),n("span",{class:"token punctuation"},"]"),n("span",{class:"token punctuation"},";"),s(`
        `),n("span",{class:"token class-name"},"Arrays"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"fill"),n("span",{class:"token punctuation"},"("),s("dp"),n("span",{class:"token punctuation"},","),s(),n("span",{class:"token number"},"1"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),s(`
        `),n("span",{class:"token keyword"},"for"),s(),n("span",{class:"token punctuation"},"("),n("span",{class:"token keyword"},"int"),s(" i "),n("span",{class:"token operator"},"="),s(),n("span",{class:"token number"},"0"),n("span",{class:"token punctuation"},";"),s(" i "),n("span",{class:"token operator"},"<"),s(" nums"),n("span",{class:"token punctuation"},"."),s("length"),n("span",{class:"token punctuation"},";"),s(" i"),n("span",{class:"token operator"},"++"),n("span",{class:"token punctuation"},")"),s(),n("span",{class:"token punctuation"},"{"),s(`
            `),n("span",{class:"token keyword"},"for"),s(),n("span",{class:"token punctuation"},"("),n("span",{class:"token keyword"},"int"),s(" j "),n("span",{class:"token operator"},"="),s(),n("span",{class:"token number"},"0"),n("span",{class:"token punctuation"},";"),s(" j "),n("span",{class:"token operator"},"<"),s(" i"),n("span",{class:"token punctuation"},";"),s(" j"),n("span",{class:"token operator"},"++"),n("span",{class:"token punctuation"},")"),s(),n("span",{class:"token punctuation"},"{"),s(`
                `),n("span",{class:"token keyword"},"if"),s(),n("span",{class:"token punctuation"},"("),s("nums"),n("span",{class:"token punctuation"},"["),s("j"),n("span",{class:"token punctuation"},"]"),s(),n("span",{class:"token operator"},"<"),s(" nums"),n("span",{class:"token punctuation"},"["),s("i"),n("span",{class:"token punctuation"},"]"),n("span",{class:"token punctuation"},")"),s(),n("span",{class:"token punctuation"},"{"),s(`
                    dp`),n("span",{class:"token punctuation"},"["),s("i"),n("span",{class:"token punctuation"},"]"),s(),n("span",{class:"token operator"},"="),s(),n("span",{class:"token class-name"},"Math"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"max"),n("span",{class:"token punctuation"},"("),s("dp"),n("span",{class:"token punctuation"},"["),s("i"),n("span",{class:"token punctuation"},"]"),n("span",{class:"token punctuation"},","),s(" dp"),n("span",{class:"token punctuation"},"["),s("j"),n("span",{class:"token punctuation"},"]"),s(),n("span",{class:"token operator"},"+"),s(),n("span",{class:"token number"},"1"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),s(`
                `),n("span",{class:"token punctuation"},"}"),s(`
            `),n("span",{class:"token punctuation"},"}"),s(`
        `),n("span",{class:"token punctuation"},"}"),s(`
        `),n("span",{class:"token keyword"},"int"),s(" res "),n("span",{class:"token operator"},"="),s(),n("span",{class:"token number"},"1"),n("span",{class:"token punctuation"},";"),s(`
        `),n("span",{class:"token keyword"},"for"),s(),n("span",{class:"token punctuation"},"("),n("span",{class:"token keyword"},"int"),s(" i "),n("span",{class:"token operator"},"="),s(),n("span",{class:"token number"},"0"),n("span",{class:"token punctuation"},";"),s(" i "),n("span",{class:"token operator"},"<"),s(" nums"),n("span",{class:"token punctuation"},"."),s("length"),n("span",{class:"token punctuation"},";"),s(" i"),n("span",{class:"token operator"},"++"),n("span",{class:"token punctuation"},")"),s(),n("span",{class:"token punctuation"},"{"),s(`
            res `),n("span",{class:"token operator"},"="),s(),n("span",{class:"token class-name"},"Math"),n("span",{class:"token punctuation"},"."),n("span",{class:"token function"},"max"),n("span",{class:"token punctuation"},"("),s("res"),n("span",{class:"token punctuation"},","),s(" dp"),n("span",{class:"token punctuation"},"["),s("i"),n("span",{class:"token punctuation"},"]"),n("span",{class:"token punctuation"},")"),n("span",{class:"token punctuation"},";"),s(`
        `),n("span",{class:"token punctuation"},"}"),s(`
        `),n("span",{class:"token keyword"},"return"),s(" res"),n("span",{class:"token punctuation"},";"),s(`
    `),n("span",{class:"token punctuation"},"}"),s(`
`),n("span",{class:"token punctuation"},"}"),s(`
`)])]),n("div",{class:"line-numbers","aria-hidden":"true"},[n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"}),n("div",{class:"line-number"})])],-1),d=a(`<h4 id="_3-最大子数组和" tabindex="-1"><a class="header-anchor" href="#_3-最大子数组和"><span>3. 最大子数组和</span></a></h4><ul><li>注意dp数组的定义不是直接是结果，而是i为结尾的最大子数组和</li></ul><p>定义dp[i]为以 nums[i] 为结尾的「最大子数组和」</p><p>空间优化：只保存pre记录以前一个元素结尾的最大子数组和 即可</p><blockquote><p>直接使用动态规划将dp[i]定义为[0...i]序列中的最大子序和，无法定义状态转移方程。</p><p>两者的区别是：后者的和里面是一定包含nums[i]的，但是最大子序和不一定包括最后一个元素</p><p>这样无法通过dp table的dp[n]直接给出数组的「最大子数组和」，但是可以通过遍历dp table找到最大的数值就是答案</p></blockquote><h4 id="_4-打家劫舍" tabindex="-1"><a class="header-anchor" href="#_4-打家劫舍"><span>4. 打家劫舍</span></a></h4><p>当前两个选择：抢（当前+prev2），不抢（prev1）</p><p>base case: <code>dp[0] = 0, dp[1] = nums[0];</code></p><p>状态转移方程：<code>dp[i + 1] = Math.max(nums[i] + dp[i - 1], dp[i]);</code></p><h4 id="_5-完全平方数" tabindex="-1"><a class="header-anchor" href="#_5-完全平方数"><span>5. 完全平方数</span></a></h4><p>dp[i]定义：和为i的完全平方数的最少数量</p><p>初始化：Arrays.fill(dp, Integer.MAX_VALUE); dp[0] = 0;</p><p>填充：i从1到n， j从1到j*j &lt;= i，</p><p><code>dp[i] = Math.min(dp[i], dp[i - j * j] + 1);</code></p><h4 id="_6-乘积最大子数组" tabindex="-1"><a class="header-anchor" href="#_6-乘积最大子数组"><span>6. 乘积最大子数组</span></a></h4><p>两个dp数组，分别存储当前数字为止的最大/最小乘积</p><h3 id="二维" tabindex="-1"><a class="header-anchor" href="#二维"><span>二维</span></a></h3><h4 id="_1-判断s是否为t的子序列" tabindex="-1"><a class="header-anchor" href="#_1-判断s是否为t的子序列"><span>1. 判断s是否为t的子序列</span></a></h4><p>全为小写字母</p><p>判断s是否为t的子序列，可以根据t构建一个dp数组，假设t的长度为n</p><p><code>int[][] dp = new int[n + 1][26] </code></p><p><code>dp[index][i]</code>定义为：对t中每个位置index，字母（‘a&#39; + i）在t中index及之后出现的第一个位置[index, n]</p><p>初始化的过程为从后往前填：</p><ol><li><p><code>dp[n][i] = n</code> 先填最后一行作为base case</p></li><li><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 当前字母对应的列为当前索引，其他列为对应的后一行的值</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">26</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> t<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token char">&#39;a&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><p>构建好dp后，对于不同的s在t中查询都可以借助这个dp数组来快速查询：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>  <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      index <span class="token operator">=</span> dp<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token char">&#39;a&#39;</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 查询得到可以和当前s中字母s.charAt(i)匹配的t中最靠前的字母的位置index</span>
      <span class="token comment">// 如果index == n，意味着t中index之后没有这个字母了</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
      index<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// index的位置能匹配上，换下一个位置尝试匹配</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2-不同路径" tabindex="-1"><a class="header-anchor" href="#_2-不同路径"><span>2. 不同路径</span></a></h4><p>base case：<code>dp[0][1] = 1</code>（其他的都为0，然后从第一行开始填充就能实现正确逻辑）</p><p>状态转移方程：</p><ul><li>起点到当前格子的路径数 = 起点到左边格子的路径数 + 起点到上边格子的路径数</li><li><code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1];</code></li></ul><h4 id="_3-最小路径和" tabindex="-1"><a class="header-anchor" href="#_3-最小路径和"><span>3. 最小路径和</span></a></h4><p>base case：</p><ul><li>第一行和第一列为Integer.MAX_VALUE</li><li><code>dp[0][1] = 1</code></li></ul><p>状态转移方程：</p><ul><li>起点到当前格子的最小路径和 = Math.min（起点到左边格子的最小路径和， 起点到右边格子的最小路径和） + 当前格子数字 <ul><li><code>dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i - 1][j - 1];</code></li></ul></li></ul><p><strong>2和3也可以用自顶向下的思路来写</strong></p><h2 id="_2-自顶向下递归的动态规划" tabindex="-1"><a class="header-anchor" href="#_2-自顶向下递归的动态规划"><span>2. 自顶向下递归的动态规划</span></a></h2><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">dp</span><span class="token punctuation">(</span>状态<span class="token number">1</span><span class="token punctuation">,</span> 状态<span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> 选择 <span class="token keyword">in</span> 所有可能的选择<span class="token punctuation">:</span>
        result <span class="token operator">=</span> 求最值<span class="token punctuation">(</span>result<span class="token punctuation">,</span> dp<span class="token punctuation">(</span>状态<span class="token number">1</span><span class="token punctuation">,</span> 状态<span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> result
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>将大问题转化为子问题</p><p>需要避免重复计算</p><h4 id="_1-零钱兑换" tabindex="-1"><a class="header-anchor" href="#_1-零钱兑换"><span>1. 零钱兑换</span></a></h4><p>有amount作为一个具体的要达成的目标，而且选择数量不确定且不连续（爬楼梯就是选择数量确定且连续），所以没有办法自底向上，只能自顶向下</p><p>可能不连续影响更大？因为给定coins其实也是确定的...</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> memo<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">coinChange</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> coins<span class="token punctuation">,</span> <span class="token keyword">int</span> amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        memo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>amount <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>memo<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">666</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">dp</span><span class="token punctuation">(</span>coins<span class="token punctuation">,</span> amount<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">dp</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> coins<span class="token punctuation">,</span> <span class="token keyword">int</span> amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>amount <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>amount <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>memo<span class="token punctuation">[</span>amount<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">666</span><span class="token punctuation">)</span> <span class="token keyword">return</span> memo<span class="token punctuation">[</span>amount<span class="token punctuation">]</span><span class="token punctuation">;</span>

        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> coin <span class="token operator">:</span> coins<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> subres <span class="token operator">=</span> <span class="token function">dp</span><span class="token punctuation">(</span>coins<span class="token punctuation">,</span> amount <span class="token operator">-</span> coin<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>subres <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>
            res <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> subres <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        memo<span class="token punctuation">[</span>amount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>res <span class="token operator">==</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> res<span class="token punctuation">;</span>
        <span class="token keyword">return</span> memo<span class="token punctuation">[</span>amount<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2-单词拆分" tabindex="-1"><a class="header-anchor" href="#_2-单词拆分"><span>2. 单词拆分</span></a></h4><p>使用一个memo数组，-1代表未计算，0是false，1是true</p><p>memo[i] 表示s[i,...]是否能用表示出</p><p>如果直接递归会超时（有特殊例子），需要用memo记录是否计算</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 给定s，dp函数返回s[i, s.length) 能否用wordDict中单词表示出</span>

<span class="token comment">// 使用一个memo数组，作为dp结果的备忘录</span>
<span class="token comment">// -1代表未计算，0是false，1是true</span>
memo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        
<span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>memo<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">boolean</span> <span class="token function">dp</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> wordDict<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//base case</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token comment">// 查备忘录</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>memo<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> memo<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token boolean">false</span> <span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token comment">// 计算：找到单词和s的前缀匹配，递归计算dp(s, i + len, wordDict)能否表示</span>
   <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> word <span class="token operator">:</span> wordDict<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> len <span class="token operator">=</span> word<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> len <span class="token operator">&gt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> prev <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> i <span class="token operator">+</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>prev<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">dp</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> i <span class="token operator">+</span> len<span class="token punctuation">,</span> wordDict<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 递归计算 </span>
                memo<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    memo<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="二维动态规划" tabindex="-1"><a class="header-anchor" href="#二维动态规划"><span>二维动态规划</span></a></h2><p>一行一行的填写</p><h3 id="_0-1背包问题-分割等和子集" tabindex="-1"><a class="header-anchor" href="#_0-1背包问题-分割等和子集"><span>0-1背包问题（分割等和子集）</span></a></h3><p>求和，找是否存在元素和为sum / 2</p><p><code>dp[i][j]</code>：从数组的 <code>[0, i]</code> 这个子区间内挑选一些正整数，每个数只能用一次，使得这些数的和<strong>恰好等于</strong> <code>j</code></p><p>对于「0-1 背包问题」而言就是「当前考虑到的数字选与不选」所以转移方程：<code>dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i]]</code></p><p>特殊条件：</p><ul><li><code>j</code> 恰好等于 <code>nums[i]</code> 时为true</li><li><code>j - nums[i]</code> 作为数组的下标，一定得保证大于等于 <code>0</code> ，因此 <code>nums[i] &lt;= j</code></li><li>初始化：<code>nums[0]</code>不越界的情况下：<code>dp[0][nums[0]] = true</code></li></ul><h3 id="编辑距离" tabindex="-1"><a class="header-anchor" href="#编辑距离"><span>编辑距离</span></a></h3><p><code>dp[m + 1][n + 1] </code></p><p>Base case: 空的字符串到字符串s的距离是s的长度（填充第一行和第一列）</p><p>状态转移方程：<code>dp[i][j]=</code> <code>s1[0...i]</code>和<code>s2[0...j]</code>的最小编辑距离</p><ul><li>当前字符相等：那就不用增加编辑次数，直接是<code>dp[i - 1][j - 1]</code></li><li>当前字符不相等：那就是<code>dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]</code>三个的最小值加一 <ul><li>分别代表：删除、插入、替换</li></ul></li></ul><h3 id="最长公共子序列" tabindex="-1"><a class="header-anchor" href="#最长公共子序列"><span>最长公共子序列</span></a></h3><p><code>dp[m + 1][n + 1] </code></p><p>Base case: 空的字符串到字符串s的最长公共子序列长度为0（new的时候默认值为0）</p><p>状态转移方程：<code>dp[i][j]=</code> <code>s1[0...i]</code>和<code>s2[0...j]</code>的最长公共子序列长度</p><ul><li>当前字符相等：<code>dp[i - 1][j - 1] + 1</code></li><li>当前字符不相等：那就是<code>dp[i - 1][j], dp[i][j - 1]</code>两个的最大值</li></ul><h3 id="最长回文子串" tabindex="-1"><a class="header-anchor" href="#最长回文子串"><span>最长回文子串</span></a></h3><ol><li><p>中心扩展算法</p></li><li><p>二维动态规划：</p><p><code>boolean dp[n][n] </code> 0代表不是回文串，1代表是</p><p>Base case:</p><ul><li><code>dp[i][i]= 1</code> 长度为1的子串一定是回文串</li><li><code>dp[i][i + 1]= 1</code> 长度为2的子串如果两个字符相等则为回文串</li></ul><p>状态转移方程：<code>dp[i][j]=</code> 字符串<code>s[i...j]</code>是否为回文串</p><ul><li>当前字符相等：<code>dp[i + 1][j - 1]</code></li><li>当前字符不相等：0</li></ul><p>具体实现：</p><p>只对第一个base case初始化，然后先枚举子串长度，再枚举左边界（这样才能保证计算每个值的时候用到的之前的值已经计算过了）</p></li></ol>`,69);function m(v,b){const p=e("CodeDemo");return i(),o("div",null,[k,c(p,{id:"code-demo-51",type:"normal",title:"%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0",code:"eJylUctugzAQ/JUVJ6JYVmhV9ZH20HurHnIMqHLDI4uMQbahjRD/3jWPBiRuXSEtu56ZHa9bLxeN8J48LKpSW3AVry1K/qq1uJh9qEJV1V8ST3CSwhiIMcZPVDbRDSbf0IYKKEaIscJSakqMoRCo/IPVqLJjBEJnZjOhXZAEtVVdGHgBRUp9ow127JHdsDt2y+5ZsAtY8NCRiYl1uBibFLysLa9I2Urly0Rl9vyRvh18p7bZjPBuzRlRYEa4mljxFlczZw7DB2Y08zNsiacopR9XDIJpuou01OBGAJLQbk/puZ816lBju13MXZDygZQTCSmtQHurKfTXPubRqH7EaBXpIq7olHTfhT3zQvyQZ2ow1yf+dml/inGRK+Xs1znWiXvL4L8bGGT+LFLZG6RrzZRno3Via60c7fry9HndLx1R0bI="},{default:l(()=>[r]),_:1}),d])}const w=t(u,[["render",m],["__file","4. 动态规划.html.vue"]]),f=JSON.parse(`{"path":"/algorithm/Hot100/4.%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html","title":"动态规划","lang":"zh-CN","frontmatter":{"title":"动态规划","order":4,"copyright":"<a href=\\"https://creativecommons.org/licenses/by-nc/4.0/\\">CC BY-NC 4.0协议</a>","description":"动态规划 1. 自底向上迭代的动态规划 int[] dp = new int[length] 定义base case，使用状态转移方程填充dp数组 一维 1. 爬楼梯 要到达现在，上一步有两种选择，1或者2 base case: dp[0] = 1, dp[1] = 1; 2. 最长递增子序列 注意dp数组的定义不是直接是结果，而是i为结尾的子序列的最...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/KKBlog/algorithm/Hot100/4.%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html"}],["meta",{"property":"og:site_name","content":"KK's Blog"}],["meta",{"property":"og:title","content":"动态规划"}],["meta",{"property":"og:description","content":"动态规划 1. 自底向上迭代的动态规划 int[] dp = new int[length] 定义base case，使用状态转移方程填充dp数组 一维 1. 爬楼梯 要到达现在，上一步有两种选择，1或者2 base case: dp[0] = 1, dp[1] = 1; 2. 最长递增子序列 注意dp数组的定义不是直接是结果，而是i为结尾的子序列的最..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-08-22T14:58:19.000Z"}],["meta",{"property":"article:author","content":"KK"}],["meta",{"property":"article:modified_time","content":"2024-08-22T14:58:19.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"动态规划\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-08-22T14:58:19.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"KK\\",\\"url\\":\\"https://github.com/Nikki-Gu\\"}]}"]]},"headers":[{"level":2,"title":"1. 自底向上迭代的动态规划","slug":"_1-自底向上迭代的动态规划","link":"#_1-自底向上迭代的动态规划","children":[{"level":3,"title":"一维","slug":"一维","link":"#一维","children":[]},{"level":3,"title":"二维","slug":"二维","link":"#二维","children":[]}]},{"level":2,"title":"2. 自顶向下递归的动态规划","slug":"_2-自顶向下递归的动态规划","link":"#_2-自顶向下递归的动态规划","children":[]},{"level":2,"title":"二维动态规划","slug":"二维动态规划","link":"#二维动态规划","children":[{"level":3,"title":"0-1背包问题（分割等和子集）","slug":"_0-1背包问题-分割等和子集","link":"#_0-1背包问题-分割等和子集","children":[]},{"level":3,"title":"编辑距离","slug":"编辑距离","link":"#编辑距离","children":[]},{"level":3,"title":"最长公共子序列","slug":"最长公共子序列","link":"#最长公共子序列","children":[]},{"level":3,"title":"最长回文子串","slug":"最长回文子串","link":"#最长回文子串","children":[]}]}],"git":{"createdTime":1715670016000,"updatedTime":1724338699000,"contributors":[{"name":"Nikki-Gu","email":"394632208@qq.com","commits":3}]},"readingTime":{"minutes":7.23,"words":2170},"filePathRelative":"algorithm/Hot100/4. 动态规划.md","localizedDate":"2024年5月14日","autoDesc":true}`);export{w as comp,f as data};
