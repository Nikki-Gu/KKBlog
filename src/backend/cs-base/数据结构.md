---
title: 数据结构
order: 1

copyright: <a href="https://creativecommons.org/licenses/by-nc/4.0/">CC BY-NC 4.0协议</a>
---



### 数组和链表

数组：相同类型元素；连续内存（对CPU的缓存机制友好）；随机访问，容量有限

链表：非连续内存，存储灵活，支持动态扩容；不能随机访问

- 单链表
- 循环链表
- 双向链表
- 双向循环链表



### 栈

栈：LIFO后进先出

应用场景：

- 浏览器的回退和前进
- 判断括号是否成对出现
- 反转字符串
- 维护函数调用
- DFS深度优先遍历（一条路走到黑）

实现：均为O(1)

- 数组：Arrays.copyOf(ori, newLength) 扩容
- 链表



### 队列

队列：先进先出

应用场景：

- 阻塞队列：生产者消费者模型
- 请求/任务队列：线性池
- 栈的实现
- BFS广度优先搜索（水波纹）
- 内核进程：优先级队列

实现：front前端；rear后端

- 顺序队列：存在假溢出的问题
- 循环队列：front == rear可能为空，也可能为满，解决方法：
  - 设置flag记录是空还是满
  - 当 `(rear + 1) % size == front ` 的时候就认为满；这样会有一个空间永远无法使用

- 双端队列
- 优先级队列：堆，实际上不是线性数据结构





### 堆

堆：公司层次结构

应用场景：只关心最值，多次获取最值

- 比有序数组维护顺序的效率高，插入删除时维护顺序时间复杂度为 `O(log(n))`，有序数组是`O(n)`

实现：数组，完全二叉树的形式存储

基本操作：

- 下沉heapifyDown：在自己和子节点中找最值，如果最值在子节点中，互换值并继续对这个子节点执行下沉heapifyDown
- 上升shiftUp：循环判断当前节点能否晋升

常见操作：

- 插入元素：插入到最后，上升shiftUp
- 删除元素（包括堆顶和中间）：和最后一个元素交换，删除最后一个元素`size--`，在删除元素的位置执行下沉heapifyDown
- 建堆/堆化heapify：for循环从第一个非叶子结点开始，执行下沉heapifyDown
- 堆排序：for循环从最后一个节点到第二个节点，和第一个元素交换，执行下沉heapifyDown



### 图

图：**G(V,E)**

实现：

- 邻接表
- 邻接矩阵：浪费存储空间；查询方便



### 树

二叉树：从0开始计算，第k层最多有`2^k`个节点

满二叉树：每一个层的节点树都是最大值

完全二叉树：除了最后一层外，其余层都是满的；最后一层最后一个节点左侧是满的

- 父结点和子节点的序号有着对应关系

平衡二叉树：空树 或者 左右子树高度差不超过1且为平衡二叉树

二叉查找树/二叉搜索树/BST：对于每个节点，其左子树中的所有节点值都小于该节点的值，而右子树中的所有节点值都大于该节点的值

- 缺点：形状取决于节点插入的顺序，不一定平衡，不平衡的二叉树可能退化为链表，查找时间复杂度从 O(logn) 变为 O(n)

平衡搜索树：

- AVL树：左右子树的高度差不超过1的平衡特性（最早发明的自平衡二叉树）
- 红黑树：相对于AVL树来说，其平衡操作更少，性能更好（自平衡二叉树）
- B树和B+树：自平衡多叉搜索树
  - 每个节点存储多个键值，可以降低树的高度，更好地满足局部性原理（更胖、更扁平）
  - 让逻辑上相邻的数据都能尽量存储在物理上也相邻的硬盘空间上，减少磁盘读写

- 2-3树：绝对平衡多叉搜索树

线段树



实现：

- 链式存储（链表）
- 顺序存储（数组）查找通过数组下标完成，0存储根节点，则：
  - 左子节点：2i+1
  - 右子节点：2i+2



#### 霍夫曼树

**Weighted Path Length of Tree，WPL**：从根结点到各叶结点的路径长度与相应叶节点权值的乘积之和

霍夫曼树：给定一组具有确定权重的叶节点，WPL最小的二叉树（可能有多种形态）

霍夫曼算法：给定一组具有确定权重的叶节点，构造霍夫曼树的算法：

- 选取两颗根节点权重最小的二叉树作为左右子树构造一颗新的二叉树，根节点权重为左右子树权重之和
- 重复直到只有一颗子树

霍夫曼编码：最短前缀编码。一种高效的不等长编码，保证为前缀编码（解码唯一，任一编码都不是其他编码的前缀）

- 根据霍夫曼算法构造霍夫曼树
- 左0右1



### 哈希表

解决冲突：

- 拉链法（开散列法）：存放数据的地方是一个链表
- 闭散列法：所有记录存储在散列表中，可以有不同的探查可存储地方的方法：
  - 线性探查法：顺序探查下一个是否可以存储:`h(key), h(key)+1, h(key)+2, h(key)+3, ...`
  - 二次探查法：二次方程：`h(key), h(key)+1^2, h(key)-1^2, h(key)+2^2, h(key)-2^2`
  - 双重哈希：如果目前的哈希函数冲突，再加上另一个哈希函数的值作为存储位置

应用场景：

1. 唯一标识：判断图片是否相同（图片前中后取100字节来hash）
2. 数据校验（下载文件块）
3. 会话粘滞（SessionID）负载均衡（路由到同一个服务器）
4. 分片/分布式存储：关键词查询，类似负载均衡



### 布隆过滤器Bloom Filter

解决海量数据存在性问题

检索元素是否在给定大集合中的数据结构：位数组+多个哈希函数

- 高效性能好
- 存在错误识别率和删除难度

实现：

- 存储：多个哈希函数对字符串进行计算得到多个哈希值作为索引，数组中索引对应位置置1
- 判断：使用相同哈希函数计算获取哈希值，取数组索引元素，如果全为1判断存在，否则判断不存在
  - 判断存在可能是误判，不存在一定正确

应用场景：

- 防止缓存穿透（在缓存层面对请求进行预过滤，识别出可能不存在在底层存储中的请求，从而减轻不必要的查询压力）
- 爬虫去重

已有实现：

- Google的Guava提供的BF：只能单机使用，容量扩展不容易
- Redis中的BF：redis-stack doker镜像部署



