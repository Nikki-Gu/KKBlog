---
title: 图解网络总结
order: 2

copyright: <a href="https://creativecommons.org/licenses/by-nc/4.0/">CC BY-NC 4.0协议</a>

---

### URL请求过程发生了什么

传输层协议通过端口号来区分不同的应用服务，浏览器（客户端）这边使用随机端口号，目标服务器一般使用默认端口，比如HTTP的80和HTTPS的443。



如果服务器提供了多个HTTP服务，域名不同，IP地址相同，端口号相同，怎么区分不同服务呢？

> 这时候就需要用到HTTP请求头里面的Host字段来指定请求的具体服务
>
> 所以Host字段实现了对虚拟主机的支持，所谓虚拟主机就是多个服务器共用一台主机，但外部看上去像是不同的服务器主机提供的服务



网卡是什么

> 将数字信息转换为电信号在网络上发送的硬件设备，需要网卡驱动操作系统才能控制网卡。
>
> 网卡驱动获取网络包之后，会将其**复制**到网卡内的缓存区中，接着会在其**开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列FCS**。
>





如果客户端有多个网卡，选择哪个作为IP数据包的源地址呢？

> 每个IP地址对应一个网卡，每个网卡通常连接到不同的网络或子网上。如果客户端主机具有多个网卡（IP地址），需要根据目标地址来选择合适的网卡（IP地址）。
>
> 具体来说，会根据目标地址和路由表规则来选择（路由匹配）
>
> 目标地址和子网掩码进行与运算得到目标子网地址，如果和路由表的Destination相同，就使用这个IP地址作为源IP地址。（理论上来讲，会选择离目标网络地址更近的网卡）



已经知道源IP地址和目的IP地址，最开始是发送给哪个MAC地址？

> 主机使用子网掩码分别计算目标地址和源IP地址的的网络地址，如果相同则说明在同一网络段，直接通过ARP协议获取目标MAC地址，发送
>
> 不相同说明不在同一网络段，填入路由器的MAC地址（先通过ARP协议获取路由器的MAC地址，填入MAC头部然后发送给路由器）



交换机做什么

> 通过FCS检验数据，无误的话放入缓冲区，在MAC 地址表中查询接收方MAC地址对应的端口并发送，如果找不到就广播
>
> 交换机MAC地址表存放网线端口和对应连接的MAC地址
>
> **交换机的端口不具有 MAC 地址**，只会原样转发数据



路由器和交换机的区别

> - **路由器**是基于 IP 设计的，俗称**三层**网络设备，路由器的各个端口都具有 MAC 地址和 IP 地址；
> - **交换机**是基于以太网设计的，俗称**二层**网络设备，交换机的端口不具有 MAC 地址。



路由器做什么

> 检查 MAC 头部中的**接收方 MAC 地址**是否为自己，是则接收，否则丢弃
>
> 接收后拆包MAC头部，丢弃
>
> 路由器通过路由表的网关列判断是否找到目标IP：
>
> - 为空：找到，直接ARP协议找目标IP的MAC地址，生成MAC头部并发送
> - 不为空：继续转发到下一个网关，生成MAC头部并发送



网关是什么

> 网关是一个抽象概念，具体实现有路由器、交换机、防火墙。



## TCP

> 什么是TCP，什么是连接

TCP 是**面向连接的、可靠的、基于字节流**的传输层通信协议。

连接：客户端与服务端达成如下消息的共识：

- **Socket**：由 IP 地址和端口号组成
- **序列号**：用来解决乱序问题等
- **窗口大小**：用来做流量控制

> 怎么确定一个TCP连接

TCP四元组：

- 源地址
- 源端口
- 目的地址
- 目的端口

> 如何理解TCP面向字节流，UDP面向报文？TCP粘包问题是什么

消息边界：一条有含义的消息的长度

**每个 UDP 报文就是一个用户消息的边界**，而TCP消息可能会被拆分（取决于发送窗口、拥塞窗口以及当前发送缓冲区的大小等条件），无法确定消息边界

TCP粘包问题：当两个消息的某个部分内容被分到同一个 TCP 报文时，这时接收方不知道消息的边界的话，无法读出有效的消息。

解决：应用层协议定义消息边界，比如HTTP

- 特殊字符：HTTP 通过设置回车符、换行符作为 HTTP 消息头和消息体的边界
- 自定义消息结构

> 没有 accept，能建立 TCP 连接吗？

能，accept是建立连接之后的系统调用，可以从全连接队列里面获取文件描述符

> TCP三次连接能携带数据吗？

**第三次握手是可以携带数据的，前两次握手是不可以携带数据的**

> TCP的超时重传机制？

1. 使用RTO超时重传时间，超过RTO就重发
2. 超时间隔加倍：遇到一次超时重传，RTO加倍

`RTT`是包的往返时间，用来计算RTO：采用RTT，对RTT加权平均；采样RTT的波动范围；

> TCP的快速重传

解决超时周期可能很长的问题，快速重传是数据驱动的：

1. 收到三个相同的 ACK 报文时，即使定时器没过期（没到达RTO）也会立刻重传丢失的报文段

> SACK是什么？

重传的一种确认方法，用于实现只重传丢失的数据。因为快速重传不知道具体丢失了哪部分的数据，该重传一个还是多个。

在TCP头部添加一个SACK字段，**将已收到的数据的信息发送给「发送方」**，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以**只重传丢失的数据**。

> 为什么要用滑动窗口？

TCP 通过让接收方指明希望从发送方接收的数据大小（窗口大小）来进行流量控制。

不用滑动窗口就是一问一答，每次发送方只能发送一个数据，等到应答ACK了之后，才能继续发送下一个数据

滑动窗口可以记录还没有收到确认的已发送报文，收到确认之后移除



所以滑动窗口大小是无需等待确认应答，可以连续发送数据的最大值

- 滑动窗口本质是缓存区
- 发送窗口 `swnd` 和接收窗口 `rwnd` 是约等于的关系：接收方有一个窗口用来接收数据，使用window字段告诉发送方自己的缓冲区可以接收多少数据，所以，发送方窗口的大小是由接收方的窗口大小来决定的
- 发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据。

> 为什么需要拥塞控制？

**避免「发送方」的数据填满整个网络。**所以TCP使用「**拥塞窗口**」调节「发送方」所要发送数据的量

**拥塞窗口 cwnd**是发送方维护的一个的状态变量，它会根据**网络的拥塞程度动态变化的**。

加入了拥塞窗口的概念后，此时发送窗口的值是`swnd = min(cwnd, rwnd)`，也就是拥塞窗口和接收窗口中的最小值。

> 拥塞控制原则：

拥塞窗口 `cwnd` 变化的规则：

- 只要网络中没有出现拥塞，`cwnd` 就会增大；
- 但网络中出现了拥塞，`cwnd` 就减少；

拥塞判断：只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是**发生了超时重传，就会认为网络出现了拥塞。**

> 拥塞控制算法有哪些？

一般画图的都是假定拥塞窗口 `cwnd` 和发送窗口 `swnd` 相等，没有考虑接收窗口的大小，所以才会指数增长、线性增长

- 慢启动：
  - **当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。**
  - 慢启动门限 `ssthresh` （slow start threshold）状态变量，当 `cwnd` >= `ssthresh` 时，使用「拥塞避免算法」；一般来说 `ssthresh` 的大小是 `65535` 字节
- 拥塞避免：**每当收到一个 ACK 时，cwnd 增加 1/cwnd。**
- 拥塞发生：有数据包丢失需要重传时进入拥塞发生
  - 使用超时重传：`ssthresh` 设为 `cwnd/2`；`cwnd` 重置为初始化值
  - 使用快速重传：`ssthresh = cwnd` ；`cwnd = cwnd/2` ；进入快速恢复
- 快速恢复

### UDP

头结构：4个字节，每个字段16位

- 目标端口
- 源端口
- 包长度：UDP报文总长度，该字段保存了 UDP 首部的长度跟数据的长度之和
- 校验和：校验和是为了提供可靠的 UDP 首部和数据而设计，防止收到在网络传输中受损的 UDP 包

> TCP和UDP可以用同一个端口号吗？

可以的，端口号是用来区分应用层的应用的，TCP和UDP是传输层的选择，接收到IP数据包拆开后获取到IP头部信息中就有协议，可以确定是TCP还是UDP



## IP

 **MAC 的作用则是实现「直连」的两个设备之间通信，而 IP 则负责在「没有直连」的两个网络之间进行通信传输。**

在网络中数据包传输中也是如此，**源IP地址和目标IP地址在传输过程中是不会变化的（前提：没有使用 NAT 网络），只有源 MAC 地址和目标 MAC 一直在变化。**

IP 地址根据网卡来配置

IP 地址分类成了 5 种类型，分别是 A 类、B 类、C 类、D 类、E 类。

解析IP地址：不管是路由器还是主机解析到一个 IP 地址时候，我们判断其 IP 地址的首位是否为 0，为 0 则为 A 类地址，那么就能很快的找出网络地址和主机地址。

主机号全0标识网络；主机号全1标识广播



无分类地址方案

表示形式 `a.b.c.d/x`，其中 `/x` 表示前 x 位属于**网络号**， x 的范围是 `0 ~ 32`

通过网络号/子网掩码来区分网络地址和主机地址



子网掩码还可以将主机地址分为两个部分：

- 子网网络地址：子网号
- 子网主机地址：



- 未做子网划分的 ip 地址：网络地址＋主机地址
- 做子网划分后的 ip 地址：网络地址＋（子网网络地址＋子网主机地址）