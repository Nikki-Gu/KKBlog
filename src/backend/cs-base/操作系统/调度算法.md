---
title: 调度算法
order: 1

copyright: <a href="https://creativecommons.org/licenses/by-nc/4.0/">CC BY-NC 4.0协议</a>
---

## 进程调度

先来先服务：FIFO队列；不利于短作业

最短作业优先：按照长短排序；不利于长作业

高响应比优先：响应比优先级 = 等待时间/ 要求服务时间 + 1

- 等待时间相同，越短优先级越高
- 要求服务时间相同，等待时间越长优先级越高



时间片轮转：固定的时间片运行时间

优先级调度：优先级越高越先执行

多级反馈队列调度：多个不同优先级的队列

- 优先级越高运行时间片越短
- 新的进程会被放入到第一级队列的末尾，按先来先服务的原则排队等待被调度，如果在第一级队列规定的时间片没运行完成，则将其转入到第二级队列的末尾，以此类推，直至完成；
- 当较高优先级的队列为空，才调度较低优先级的队列中的进程运行。如果进程运行时，有新进程进入较高优先级的队列，则停止当前运行的进程并将其移入到原队列末尾，接着让较高优先级的进程运行；



## 页面置换算法

OPT最佳页面置换算法：**置换在「未来」最长时间不访问的页面**。

FIFO先进先出

Lock时钟：遇到访问位为1的修改为0，第一个访问位为0的淘汰

- 当一个页面被装入内存时，把该位初始化为0
- 如果这个页面被访问（读/写），则把该位置为1；
- 把各个页面组织成环形链表（类似于钟表面），把指针指向最老的页面（最先进来）；

LRU（Least Recently Used）最近最久未使用：**选择最长时间没有被访问的页面进行置换**，就是选择最久没有使用的页面换出

- 使用LinkedHashMap实现，双向链表 + HashMap 
  - 双向链表是为了删除方便
  - HashMap是为了快速定位节点位置

LFU（Least frequently Used）最不频繁访问的：每个页面对应一个访问次数，淘汰访问次数最小的页面

- 使用HashMap + LinkedHashSet

  - 使用一个 `HashMap` 存储 `key` 到 `val` 的映射，就可以快速计算 `get(key)`

  - 使用一个 `HashMap` 存储 `key` 到 `freq` 的映射，就可以快速操作 `key` 对应的 `freq`

  - 需要 `freq` 到 `key` 的映射，用来找到 `freq` 最小的 `key`；一个freq对应多个key；需要移动key实现freq +1

    ```java
    HashMap<Integer, LinkedHashSet<Integer>> freqToKeys;
    int minFreq = 0;
    ```




## 磁盘调度算法

按照半径不同划分磁道（0-199），每个磁道上多个扇区

磁盘调度算法是要优化磁盘的访问请求顺序，减少移动的磁道的距离



先到先服务

最短寻道时间：会导致饥饿，总是访问一个范围内的磁道，远的被饥饿

扫描算法/电梯算法：固定一个方向扫描服务请求，直到到头再改变方向并继续服务；中间访问频率高，两边访问频率少，每个磁道响应的频率存在差异

循环扫描C-SCAN：磁道只有朝固定方向移动时响应请求，然后快速回到原点中途不响应

LOOK：**磁头在移动到「最远的请求」位置，然后立即反向移动**，**反向移动的途中会响应请求**

C-LOOK：磁道只有朝固定方向移动时响应请求，然后快速回到最远请求位置，返回中途不响应

