---
title: 内存管理
order: 3

copyright: <a href="https://creativecommons.org/licenses/by-nc/4.0/">CC BY-NC 4.0协议</a>
---

虚拟内存的作用：

1. 可以使得进程运行内存超过无力内存大小，利用硬盘swap区域存储没有使用的内存，利用了局部性原理

2. 每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的，解决了多进程之间地址冲突的问题

   > 并不保证进程之间的内存隔离，进程还是有可能访问其他进程的物理内存
   >
   > 非法指针、缓冲区溢出

## 分段

将程序按照逻辑分段，按照实际需求分配内存

分段机制把程序的虚拟地址分成四个段（栈、堆、数据、代码），每个段对应一个基地址和段界限



分段机制中虚拟地址是通过**段表**和物理地址进行映射的：

- 虚拟地址由两部分组成，**段选择因子**和**段内偏移量**
- 从段选择因子里面取段号，到段表里面去查询物理内存空间里面的起始地址
- 物理内存地址 = 起始地址+段内偏移量



存在的问题：

1. 外部内存碎片

   分段按照实际需求分配内存，不会出现内部内存碎片，但是段的长度不固定，所以有外部内存碎片问题

   解决「外部内存碎片」的问题：**内存交换**，在硬盘中划分出来一块swap空间专门用于内存交换，将内存读出到swap空间，然后读入的时候紧接着分配的空间装载

2. 内存交换效率低

   如果内存交换的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿

## 分页

总结：分页可以结局外部内存碎片的问题，可以按需加载，换页方便（固定大小），但是使用单级页表太大，所以使用多级页表，使用多级页表查找效率比较低，所以使用TLB（页表缓存、转址旁路缓存、快表）

### 定义

把虚拟和物理内存划分为大小相同的页，在 Linux 下，每一页的大小为 `4KB`

分段机制中虚拟地址是通过**页表**和物理地址进行映射的：

- 虚拟地址由两部分组成，**页号**和**页内偏移量**
- 用页号去页表里面查询物理页号（物理内存基地址）
- 物理内存地址 = 基地址 + 页内偏移量

存在内部内存碎片

按需加载：在加载程序的时候，如果分配的虚拟内存没有访问是不会映射到物理内存的。

只有在访问已分配的虚拟地址空间的时候，操作系统通过查找页表，发现虚拟内存对应的页没有在物理内存中，就会触发**缺页中断**，进行内存分配，再建立虚拟内存和物理内存之间的映射关系。

### 多级页表

页表很大：页表一定要覆盖全部虚拟地址空间（也就是进程想要存的东西，一定是真的存下来，有物理地址可以寻址的）

具体单级页表大小计算：如果是32位的系统，虚拟地址空间大小为4GB，每个进程都要4GB的虚拟地址空间，每个页的大小是4KB，则每个进程都需要有2^20（1M = 4GB / 4KB）个页表项，每个页表项使用4个字节来粗处，则需要4MB的内存来存储页表

用多级页表解决

- 总的是1MB个页表项，如果按照每个二级页表有1K条来划分，则需要1K个二级页表
- 创建一个一级页表映射二级页表数目，则一级页表有1K项
- 这样只有1K项，每一项4B，一共4KB就覆盖了整个虚拟地址空间
- 二级页表按需创建，因为显然对于大多数程序来说，其使用到的空间远未达到 4GB，所以大部分页表项都是空的不需要分配

64 位的系统，两级分页不够了，使用四级目录

> 虚拟地址空间大小：取决于CPU处理能力能处理多少位的数据
>
> 物理内存大小：取决于硬件
>
> 32位处理器一般理论寻址空间2^32Bytes，可以分配2^32个地址，每个地址存储一个字节数据所以是2^32B
>
> 2^32 = 2^10（K）\* 2^10(M) \* 2^10(G) \* 4
>
> 1K = 2^10 = 1024
>
> 1M = 2^20 = 1024 * 1024
>
> 1G = 2^30 = 1024 * 1024 * 1024
>
> 1 TB = 1024 GB

## 段页式

虚拟地址 = **段号 + 段内页号 + 页内位移**

段页式地址变换中要得到物理地址须经过三次内存访问：

- 第一次访问段表，得到页表起始地址；
- 第二次访问页表，得到物理页号；
- 第三次将物理页号与页内位移组合，得到物理地址。

## Linux的内存分布

虚拟地址空间的内部分为**内核空间和用户空间**两部分

其中用户态的分布（由低到高）：代码段、全局变量、BSS、函数栈、堆内存、映射区。

32位，一共4G虚拟地址空间：1G内核空间+3G用户空间

64位：内核在上面128T，用户在下面128T，其他未定义（只使用了48位来表示虚拟地址）

**虽然每个进程有自己的虚拟内存空间，但是每个虚拟内存中的内核地址，关联的都是相同的物理内存**

## 内存分配

**缺页中断**：访问到没有被分配的虚拟内存，CPU产生缺页中断，进程会从用户态切换到内核态，并将缺页中断交给内核的 Page Fault Handler （缺页中断函数）处理。

 Page Fault Handler （缺页中断函数）会去看是否有空闲的物理内存：

- 如果有，就直接分配物理内存，并建立虚拟内存与物理内存之间的映射关系。
- 如果没有空闲的物理内存，那么内核就会开始进行内存回收
  - 回收后满足要求，分配
  - 空闲的物理内存仍然不满足要求，OOM

## 内存回收

有两种方式，分别是线程异步的后台回收和阻塞的直接回收：

- **后台内存回收**（kswapd）：在物理内存紧张（空闲内存低于阈值）的时候，会唤醒 kswapd 内核线程来回收内存，这个回收内存的过程**异步**的，不会阻塞进程的执行。

- **直接内存回收**（direct reclaim）：如果后台异步回收跟不上进程内存申请的速度，就会开始直接回收，这个回收内存的过程是**同步**的，会阻塞进程的执行。

  内存不足的时候进行直接内存回收

> Swap 换入换出的是什么类型的内存？
>
> 1. 内核缓存的文件数据，因为都有对应的磁盘文件， 直接写回到对应的文件，释放内存
> 2. 匿名页：进程的堆、栈数据等，它们是没有实际载体；需要写到磁盘的 Swap 分区中

### 4GB 物理内存的机器上，申请 8GB 内存，会怎么样？

32位：不行，最多只能申请3GB内存

64位：`128T = 128 * 1024GB >> 4GB`，可以申请

申请后具体能否使用要看操作系统有没有开启 Swap 机制：

- 如果没有开启 Swap 机制，程序就会直接 OOM；
- 如果有开启 Swap 机制，程序可以正常运行。



64位机器能申请128T内存吗？如果只有2GB物理内存，大概率不行，因为页表是存储在物理内存上的，申请过程中物理内存放不下了就无法申请，但是如果开启了swap机制，就可以

