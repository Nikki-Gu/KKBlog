---
title: 锁的实现
order: 6

copyright: <a href="https://creativecommons.org/licenses/by-nc/4.0/">CC BY-NC 4.0协议</a>
---

# 锁的实现

## 互斥锁和自旋锁

最基本最底层的两种锁，更高级的锁都会选择其中一个来实现，选择原则：

- 被锁住的代码执行时间很短，应该选用自旋锁，否则使用互斥锁

互斥锁和自旋锁的区别在于对于加锁失败后的处理方式不同：

- **互斥锁**加锁失败后，线程阻塞并**释放 CPU** 给其他线程
  - 由内核实现：加锁失败而阻塞，可以获取到锁之后唤醒线程获取锁
  - 加锁失败的线程至少存在两次主动的上下文切换成本（还有被动的比如时间片用完了的切换）
- **自旋锁**加锁失败后，线程会**忙等待**，直到它拿到锁
  - 由CPU 提供的 `CAS` 函数（*Compare And Swap*）在用户态实现，不会主动产生线程上下文切换
  - 单核非抢占调度器不可用，不然可能会一直忙等
  - 自旋的时间和被锁住的代码执行的时间是成「正比」的关系



## 读写锁

定义

- 写锁：互斥
- 读锁：共享

不同实现

- 读优先
- 写优先
- 公平：用队列把获取锁的线程排队，不管是写线程还是读线程都按照先进先出的原则加锁

读写锁可以根据场景选择互斥锁和自旋锁其中的一个进行实现



## 乐观锁和悲观锁

悲观锁：假定冲突的概率很高，访问共享资源前先上锁；互斥锁、自旋锁、读写锁，都是属于悲观锁。

乐观锁：假定冲突的概率很低，先修改资源再验证是否有冲突需要处理

