---
title: JVM
order: 9
copyright: <a href="https://creativecommons.org/licenses/by-nc/4.0/">CC BY-NC 4.0协议</a>
---

## Java内存区域

- Java堆
  - 字符串常量池
- 栈：一个栈帧中包括局部变量表、操作数栈、动态链接、返回地址
  - 虚拟机栈
  - 本地方法栈
  - 程序计数器
- 直接内存（不在JVM的内存区域中，通过操作系统调用创建）
  - 元空间metaspace（之前的永久代）
    - 方法区：抽象概念，JDK1.8之后使用元空间来实现
      - 类信息、属性信息、方法信息（方法表）、常量、静态变量
      - JIT代码缓存
      - 运行时常量池：字面量和符号引用



### 对象创建过程

在代码中使用new的时候经历的过程：

1. 加载检查：去运行时常量池查找这个类是否已经加载
2. 给对象在Java堆上分配内存

3. 对象头信息设置
4. 调用构造方法， Class 中的 `<init>()` 方法来初始化对象

### 如何为对象分配内存

分配内存的时候，按照Java堆是否规整有两种分配方式

- 规整的情况：指针碰撞
- 不规整的情况：空闲列表，使用列表维护区域的可用性

Java堆是否规整取决于使用的垃圾收集器是否带有空间压缩整理能力

### 如何保证并发分配线程安全

并发分配内存保证线程安全的方案：

- CAS+失败重试
- TLAB（Thread Local Allocation Buffer）：每个线程在Java堆中预先分配有一块内存，优先分配TLAB中的内存

### 对象的内存布局

- 对象头
  - 运行时数据：哈希码、GC分代年龄等
  - 类型指针：指向其Class类
- 实例数据
- 对齐填充

### 对象的访问方式

- 句柄：引用中存储的是句柄地址
  - 句柄中存储：
    - 对象实例数据的指针
    - 对象类型数据的指针
- 直接访问：引用中存储的就是对象实例数据的地址（主要实现）

## 类加载器TODO



## 垃圾回收TODO

主要对Java堆进行垃圾回收，回收死亡的对象（不可能再使用的对象）

### 判断对象死亡的方法

1. 引用计数器：无法避免互相引用的问题
2. 可达性分析：主要使用方式
   - 使用`GC Roots`对象作为起始结点搜索，不可达的对象为死亡对象
   - 固定 `GC Roots` 的对象 + 临时性对象组成`GC Roots`集合

[JVM](https://javabetter.cn/jvm/zongjie.html#_3-%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8)



