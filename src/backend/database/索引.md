---
title: 索引
order: 2

copyright: <a href="https://creativecommons.org/licenses/by-nc/4.0/">CC BY-NC 4.0协议</a>
---



## 文件存储

表数据可以放在共享表空间文件和独占表空间文件中

现在MySQL默认设置是一张数据库表保存在对应的`table_name.idb`文件中，这个文件也被称为独占表空间文件

**表空间由段（segment）、区（extent）、页（page）、行（row）组成**

- row：row_format（一条数据的存储结构）
- page：数据页；读取/管理数据的基本单位，16KB
- extent：1MB的大小，64个连续的页
- segment：索引段、数据段、回滚段

一个表就是按照主键索引B+树的结构组织起来存储的

#### 页格式

B+树中每个结点是一个数据页

数据页包括7个部分：文件头、页头、最小记录、最大记录、用户记录、页目录、文件尾

文件头：最重要的信息是有两个指针 PAGE_NEXT 和 PAGE_PRE，分别指向后一个数据页和前一个数据页。将多个数据页组成双向链表

最小记录、最大记录和用户记录都是行格式存储的

最小记录：链表的头结点；record_type=2

最大记录：链表的尾结点；record_type=3

用户记录：

- 行格式拼接组成，记录行的存放没有逻辑顺序，但是会按照主键值对记录行组织成一条单向升序链表
- 链表指针存放在：记录行-行格式-记录头信息-next_record中
- 如果当前页是非叶子结点：record_type=1
- 如果当前页是叶子结点，record_type=0

页目录：数组结构；加快一个数据页中找到目标记录行的效率；将上面的记录行的有序链表分为多个组，每个组内最后一条记录的指针存放在目录中（页目录中中每一项指向的是**当前分组的最后一条记录**）

页分裂：需要保证页面有序组织，插入元素到一个已经满的页面时需要页分裂，移动插入后面的记录到新的数据页中，很耗时；

避免页面分裂：主键应该保持升序，避免页分裂操作，这样插入的时候只需要在数据页最后插入/用新的数据页面存放插入数据

#### 行格式类型

InnoDB提供了四种行格式，5.7之后默认Dynamic格式

- Redundant
- Compact
- Dynamic：基于Compact改进
- Compressed：基于Compact改进

#### Compact行格式

一行记录的存储 = 记录的额外信息 + 记录的真实数据

##### 记录的额外信息

- 变长字段长度列表（0-2字节）：保存变长字段的真实数据占用的字节数，按照列的顺序逆序排列
  - 如果表定义了没有变长字段，就没有这一块信息
  - 如果变长字段允许存储的最大字节数小于等于 255 字节，就会用 1 字节表示「变长字段长度」
  - 如果变长字段允许存储的最大字节数大于 255 字节，就会用 2 字节表示「变长字段长度」
- NULL值列表（0字节往上）：1字节不够时使用2字节，以此类推
  - 如果表定义了所有字段都是NOT NULL，没有这一块信息
  - 如果有一个列可以为NULL，则每个列都对应一个bit，按照列的顺序逆序排列
    - 二进制位的值为`1`时，代表该列的值为NULL
    - 二进制位的值为`0`时，代表该列的值不为NULL
- 记录头信息：5个字节
  - 比如：delete_mask、record_type、next_record、n_owned（页目录指向的最后一条记录存放当前组的行记录条数）


##### 记录的真实数据

- 隐藏字段：
  - row_id：没有主键或者唯一约束列时候的主键；不是必须的，占用6个字节
  - trx_id：事务id，表示这个数据是由哪个事务生成的。 trx_id是必需的，占用 6 个字节
  - roll_pointer：记录上一个版本的指针。roll_pointer 是必需的，占用 7 个字节
- 真实数据

#### varchar(n) 中 n 最大取值为多少？

n是可以存储的字符数，使用ascii字符集，1个字符占用1个字节，

**MySQL 规定除了 TEXT、BLOBs 这种大对象类型之外，【变长字段长度列表+NULL值列表+真实数据】不能超过65535个字节**

如果设置为NOT NULL，只有varchar一个列，则n最大取值为65535 - 2 = 65533

在UTF-8 字符集下，一个字符最多需要三个字节，则n最大取值为65533/2

### 行溢出怎么处理

一个页的大小一般是 `16KB`，也就是 `16384字节`，一个 varchar(n) 类型的列最多可以存储 `65532字节`

行溢出：一个页存储不下一条记录的情况

解决：剩余数据放到溢出页中

- Compact 行格式：记录的真实数据处保存该列的一部分数据，用20字节存储指向溢出页的地址
- Compressed 和 Dynamic：记录的真实数据处只存储 20 个字节的指针来指向溢出页

## 索引

### 优缺点

优点：加快检索速度；创建唯一性索引可以保证数据唯一性

缺点：维护索引耗费时间；存储索引耗费空间

### 索引数据结构选择

- Hash：等值查询最快，但是不支持顺序查询和范围查询
- 二叉查找树：退化为斜树，不平衡时查找效率低下O(n)
- AVL树：维护平衡开销大，查询开销为O(log2n);
- 红黑树：二叉树，一个节点不能存储多个值，深度更大，查找次数更多
- B树：多叉树，一个节点可以存储多个值，深度不大，更胖，减少查找次数；适合大量的单个索引查询
- B+树：MyISAM和InnoDB使用；O(logdn);
  - B+树与 B 树相比：
    - 单点查询：存储数据量相同的情况（不用在非叶子节点存非索引数据），具备更少的 IO 次数、更稳定的查询效率
    - 范围查询：双向链表，非常适合范围查询
    - 插入和删除效率更高：存在很多冗余节点，删除根节点不会发生剧烈变形



| -                | B树                                                          | B+树                        |
| ---------------- | ------------------------------------------------------------ | --------------------------- |
| 内节点存放       | key, data（不会在叶子节点中再出现）                          | key（还会在叶子节点中出现） |
| 叶子结点存放     | key, data                                                    | key, data                   |
| 叶子结点之间关系 | 独立                                                         | 相互连接，支持范围查找      |
| 查找效率         | 不稳定（可能没到叶子结点就找到了）；找索引时会读入非索引数据，增加磁盘IO消耗 | 稳定（均要查找到叶子结点）  |

MySQL中B+树的每一层都是通过双向链表连接起来的

### 索引类型（底层存储方式）

- 聚集索引：索引文件里面直接存放对应数据
  - 比如：InnoDB的主键索引的实现是聚集索引
  - 优点：查询速度快；排序查找和范围查找优化
  - 缺点：依赖有序数据；更新代价大
- 非聚集索引/二级索引/辅助索引：索引文件里面存放指向数据的指针
  - 比如：
    - MyISAM的所有索引
    - InnoDB普通索引（叶子结点存放的数据是主键，如果查询的不是主键，还要用主键回表二次查询，也就是查询主键索引、B+树）
  - 优点：更新代价小
  - 缺点：依赖有序数据；可能回表（二次查询）

### 索引类型（应用方式）

- 主键索引：不能有null；加速+唯一
- 唯一索引：可以有null；加速+唯一
- 普通索引：加速
- 覆盖索引：索引包含需要查询字段的值
- 联合索引：多个字段创建索引
  - 假设有一个联合索引`(column1, column2, column3)`，相当于创建了 3 个索引：
    - `(column1)`
    - `(column1, column2)`
    - `(column1, column2, column3)`
  - 实际上就是创建的一个索引，但是这个索引的B+树是先按照column1来排序的，column1相同的才按照column2顺序组织
  - 联合索引当遇到范围查询 (>、<) 就会停止匹配
  - 最左前缀匹配原则：从左到右依次匹配查询条件中的字段，只有匹配到了才能用上索引查询


### 索引下推ICP（Index Condition Pushdown）

定义：在索引遍历的过程中执行部分where子句的判断条件，直接过滤掉不满足条件的记录

作用：减少**二级索引**在查询时的回表操作，提高查询的效率，因为它将 Server 层部分负责的事情，交给存储引擎层去处理

- 不使用ICP：每找到一条满足一个条件的记录就回表查询，将结果返回给Server，Server去判断是否满足其他条件
- 使用ICP：每找到一条满足一个条件的记录，先通过索引判断条件是否成立，不成立直接跳过，成立则执行回表查询，将结果返回给Server



[记录行与数据页](https://zhuanlan.zhihu.com/p/639042049)
