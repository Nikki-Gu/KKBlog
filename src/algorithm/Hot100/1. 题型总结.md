---
title: Hot100总结
order: 1

copyright: <a href="https://creativecommons.org/licenses/by-nc/4.0/">CC BY-NC 4.0协议</a>
---



两数之和：哈希表

三数之和：排序+左右指针

排列-组合-子集问题：回溯算法

子数组问题：前缀和、定义以当前元素结尾的动态规划表



数组和矩阵部分几乎全是数学技巧，需要记下来

> 4.30复习需要继续巩固的：
>
> 1.2使用到的API：
>
> - String的排序，需要转为char数组，然后Arrays.sort
>   - String和char的转换：toCharArray；new String(char[])
> - `new ArrayList(map.values())`
>
> 2.4：`Arrays.asList(nums[i], nums[left], nums[right])`

常用包：

```Java
import java.io.*
import java.util.*
import java.lang.*
```

## 一、哈希

### 常用API

`HashMap`

- `containsKey(key)`
- `put(key, value)`
- `get(key)`
- `getOrDefault(key, 0)`
- `map.values()`
  - set类型，将map.values转为List：`new ArrayList(map.values())`

- `map.keys()`
- `map.keySet().iterator().next()` 第一个元素
- `size()`

`HashSet`

- `add()` 
- `contains(key)`
- 遍历访问 
  - `for(int num : set)`
  - `iterator().hasNext()`

### 1. 两数之和

快速查找`need = target - nums[i]`是否在`HashMap`中，如果在就得到结果，返回

否则存储`map.put(nums[i], i);`

::: normal-demo  代码实现

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            int need = target - nums[i];
            if (map.containsKey(need)) {
                return new int[]{map.get(need), i};
            } else {
                map.put(nums[i], i);
            }
        }
        return new int[]{-1, -1};
    }
}
```

:::

### 2. 字母异位词分组

用`HashMap`进行分组，遍历字符串数组，拿到code，基于code将字符串添加到map中

::: normal-demo  代码实现

```java
public List<List<String>> groupAnagrams(String[] strs) {
    Map<String, List<String>> map = new HashMap<>();
    for (String str : strs) {
        String code = encode(str);
        if (map.containsKey(code)) {
            map.get(code).add(str);
        } else {
            map.put(code, new ArrayList<>());
            map.get(code).add(str);
        }
    }
    return new ArrayList<>(map.values()); # 返回值要注意
}
```

:::

- `key：String` 保证异位词的key相同，key可以是：

  - 异位词编码：利用每个字符的出现次数进行编码【242.有效的字母异位词：判断 `t` 是否是 `s` 的字母异位词】

    需要注意的细节：

    - `char`本质是整数，可以`++`
    - String是不可以迭代的，需要转换成Array，`s.toCharArray()`
    - 对于`char`数组可以直接`new String(code);`  比`int[]`数组`Arrays.toString(count);`快

    ```java
    private String encode(String s) {
        char[] code = new char[26];
        for (char c : s.toCharArray()) {
            int delta = c - 'a';
            code[delta]++;
        }
        return new String(code);
    }
    ```
  - 字符串排序后的结果作为key

    ```java
    public String encode(String str) {
        char[] tmp = str.toCharArray();
        Arrays.sort(tmp);
        return new String(tmp);
    }
    ```

### 3. 最长连续序列

使用`HashSet`存放所有元素

遍历`HashSet`找序列的第一个元素[遍历原有集合而不是set的话运行时间显著增加]；

- ` if (set.contains(num - 1)) continue;`
- 找到可能的第一个元素，计算以这个元素为首的序列长度；更新最长序列长度

::: normal-demo  代码实现

```java
class Solution {
    public int longestConsecutive(int[] nums) {
        Set<Integer> set = new HashSet<>();
        int res = 0;
        for (int num : nums) {
            set.add(num);
        }
        for (int num : set) {
            if (set.contains(num - 1)) continue;
            int tmp = num;
            int length = 1;
            while (set.contains(tmp + 1)) {
                tmp++;
                length++;
            }
            res = Math.max(res, length);
        }
        return res;
    }
}
```

:::

时间复杂度分析：关键在于**每个元素最多只被访问两次**：一次是在外层循环中，一次是在内部循环中（如果它是某个序列的一部分）。因此，尽管有嵌套的循环，所有操作的总复杂度依然是线性的



补充一下暴力解法和时间复杂度分析：对数组中的每个数，去找以它开始的最长序列长度(while循环去找)，每次找都需要遍历一遍数组元素。

按照下面的解法，时间复杂度是$O(n^3)$

::: normal-demo  暴力解法

```java
class Solution {
    static long beginTime = System.currentTimeMillis();
    static long overTime = 1 * 1000; // 1s

    public int longestConsecutive(int[] nums) {
        int res = 0;
        for (int num : nums) {
            long nowTime = System.currentTimeMillis();
            if ((nowTime - beginTime) > overTime) {
                System.out.println("超时退出");
                break;
            }
            int length = 1;
            int tmp = num;
            while (find(tmp + 1, nums)) {
                tmp++;
                length++;
            }
            res = Math.max(res, length);
        }
        return res;
    }
    public boolean find(int target, int[] nums) {
        for (int num : nums) {
            if (num == target) {
                return true;
            }
            
        }
        return false;
    }
}
```

:::

### 4. 和为K的子数组

> 和 二叉树-8 路径总和 相似思路

子数组是连续的，所以可以通过前缀和的思路求解；按照前缀和相减得到所求k的思路，公式为`k = preSum[i] - preSum[j - 1]`

使用`Map<Integer, Integer> map`，存储`<preSum前缀和, 该前缀和出现次数>`；需要初始化` map.put(0, 1);`

需要遍历数组计算前缀和，并将前缀和放入map中；同时从map中获取`当前元素的前缀和-k`的出现次数，更新计数结果`res+= map.get(preSum - k);` 

::: normal-demo  代码实现

```java
public int subarraySum(int[] nums, int k) {
    Map<Integer, Integer> map = new HashMap<>();
    map.put(0, 1);
    int res = 0;
    int preSum = 0;
    for (int num : nums) {
        preSum += num;
        if (map.containsKey(preSum - k)) {
            res += map.get(preSum - k);
        }
        map.put(preSum, map.getOrDefault(preSum, 0) + 1);
    }
    return res;
}
```

:::

### 5. 缺失的第一个正数

根据鸽巢原理，对于一个长度为 N 的数组，其中没有出现的最小正整数只能在[1, N + 1] 中，因此可以将长度为N的数组作为HashSet，有[0, N]个巢

- 对于非正数[`nums[i] <= 0`]，不考虑；映射为N+1，相当于不加入哈希表

- 对于值在范围[1, N]的数取其绝对值abs，通过设置`nums[abs - 1]`为负数[需要先判断是否为负数，已经是负数的就不用改了] 建立Hash映射：

  ```java
  int abs = Math.abs(nums[i]);
  if (abs <= n && nums[abs - 1] > 0) {
      nums[abs - 1] = -nums[abs - 1];
  }
  ```

判断：遍历建立好的HashSet，也就是这个数组，如果index处为正数则说明index + 1不在数组中

::: normal-demo  代码实现

```java
public int firstMissingPositive(int[] nums) {
    int n = nums.length;
    for (int i = 0; i < n; i++) {
        if (nums[i] <= 0) {
            nums[i] = nums.length + 1;
        }
    }
    for (int i = 0; i < n; i++) {
        int abs = Math.abs(nums[i]);
        if (abs <= n && nums[abs - 1] > 0) {
            nums[abs - 1] = -nums[abs - 1];
        }
    }
    for (int i = 0; i < n; i++) {
        if (nums[i] > 0) {
            return i + 1;
        }
    }
    return n + 1;
}
```

:::

### 6. SetAllValues

设计一个数据结构，能在O(n)下实现如下操作：getVal、setValue、setAll

- 额外用一个hashset/map来存储setallvalues之后是否有变化

```Java
class MyDS {
     private int defaultValue;
     private Map<Integer, Integer> map;

     public MyDS() {
         defaultValue = 0;  //initialize default value
         map = new HashMap<>();
     }

     public void setAll(int val) {
         defaultValue = val;
     }

     public void setValue(int index, int val) {
       map.put(index, val);
     }

     public int getVal(int index) {
         if (map.containsKey(index)) {
           return map.get(index);
         }
         else {
           return defaultValue;
     		 }
     }
}
```

## 二、双指针

### 代码框架

```java
int left = 0, right = nums.length - 1;
while (left < right) {
	// doing
}
```

### 1. 移动零

和代码框架不同。

正难则反的思想，移动非零元素比移动零简单。因此先移动非零元素到前面，最后填充零到后面。

::: normal-demo  代码实现

```java
public void moveZeroes(int[] nums) {
    int left = 0;
    for (int i = 0; i < nums.length; i++) { # 这里的i相当于right指针
        if (nums[i] != 0) {
            nums[left++] = nums[i];
        }
    }
    while (left < nums.length) {
        nums[left++] = 0;
    }
}
```

:::

### 2. 盛最多水的容器

> 代码框架+移动高度低的一边，统计最大值

直接理解为什么移动高度低的一边还挺直接，但从数学上证明这个解法的正确性也值得一看[官方题解]。

大体思路总结：证明移动高度高的一边容量不可能增加 => 高度低的边不可能再次使用使得容量增加 => 因此移动高度低的一边

::: normal-demo  代码实现

```java
class Solution {
    public int maxArea(int[] height) {
        int left = 0, right = height.length - 1;
        int res = 0;
        while (left < right) {
            int tmp_res = Math.min(height[left], height[right]) * (right - left);
            res = Math.max(res, tmp_res);
            if (height[left] <= height[right]) {
                left++;
            } else {
                right--;
            }
        }
        return res;
    }
}
```

:::

### 3. 接雨水

- 下标 i 处能接的雨水量等于下标 i 处的水能到达的最大高度减去 height[i]
- 下标 i 处水能到达的最大高度等于下标 i 两边的最大高度的最小值`Math.min(left_max[i], right_max[i]) - height[i]`

因此，最朴素的直接的想法是对于每个元素，分别向左向右扫描得到最大高度，计算容量。这样每个位置扫描一边时间复杂度为$O(n)$，数组有n个元素，需要扫描n次，因此时间复杂度为$O(n^2)$。

#### 优化1 —— 动态规划

扫描得到最大高度这一步，可以使用动态规划的方法，提前计算好left_max和right_max数组。其中left_max[i]表示下标i及其左边能达到的最大高度。

left_max和right_max数组具体计算公式：

- Base case：

  ```
  left_max[0] = height[0];
  right_max[n - 1] = height[n - 1];
  ```

- 当 1≤i≤n−1 时，leftMax[i]=max(leftMax[i−1],height[i])；

- 当 0≤i≤n−2 时，rightMax[i]=max(rightMax[i+1],height[i])

::: normal-demo  代码实现

```java
public int trap(int[] height) {
    int res = 0;
    int n = height.length;
    int[] left_max = new int[n];
    int[] right_max = new int[n];
    left_max[0] = height[0];
    right_max[n - 1] = height[n - 1];
    for (int i = 1; i < n; i++) {
        left_max[i] = Math.max(height[i], left_max[i - 1]);
        right_max[n - i - 1] = Math.max(height[n - i - 1], right_max[n - i]);
    }
    for (int i = 0; i < n; i++) {
        res += Math.min(left_max[i], right_max[i]) - height[i];
    }
    return res;
}
```

:::

#### 优化2 —— 双指针

在动态规划基础上可以对空间复杂度再进行优化，去掉对left_max和right_max数组的存储开销。

定义

- `l_max`为 `height[0..left]` 中最高柱子的高度
- `r_max` 为 `height[right..end]` 的最高柱子的高度

关键思路：哪边小哪边就可以计算容量并移动

ref：[双指针](https://labuladong.online/algo/frequency-interview/trapping-rain-water/)

::: normal-demo  代码实现

```java
public int trap(int[] height) {
    int left = 0, right = height.length - 1;
    int l_max = height[0];
    int r_max = height[right];
    int res = 0;
    while (left < right) {
        l_max = Math.max(l_max, height[left]);
        r_max = Math.max(r_max, height[right]);
        if (l_max < r_max) {
            res += l_max - height[left];
            left++;
        } else {
            res += r_max - height[right];
            right--;
        }
    }
    return res;
}
```

:::

### 4. 三数之和

排序：`Arrays.sort(nums);`

二分查找

::: normal-demo  代码实现

```java
public List<List<Integer>> threeSum(int[] nums) {
    List<List<Integer>> res = new ArrayList<>();
    // if (len < 3) return res; 限定条件给了3 <= nums.length <= 3000
    Arrays.sort(nums);
    for (int i = 0; i < nums.length; i++) {
        if (nums[i] > 0) break; // 剪枝
        if (i > 0 && nums[i] == nums[i - 1]) continue; // 去除重复
        int left = i + 1, right = nums.length - 1;
        while (left < right) {
            int sum = nums[i] + nums[left] + nums[right];
            if (sum == 0) {
                res.add(Arrays.asList(nums[i], nums[left], nums[right])); // 添加到res
                left++;
                right--;
                // 去除重复；sum==0的时候才需要去除重复，其他时候继续相等也不等于0
                while (left < nums.length && nums[left] == nums[left - 1]) left++;
                while (right >= 0 && nums[right] == nums[right + 1]) right--;
            } else if (sum < 0) {
                left++;
            } else {
                right--;
            }
        }
    }
    return res;
}
```

:::

## 三、滑动窗口

### 代码框架

窗口长度为`right - left`，注意这里没有`+1`，因为`right`是开区间

```java
Map<Characte, Integer> window = new HashMap<>();
int left = 0, right = 0;
int res;
while (right < s.length()) {
    // 增大窗口
  	char c = s.charAt(right);
		right++;
		window.put(c, window.getOrDefault(c, 0) + 1);
    
    while (需要缩小窗口的条件) {
      	// 更新res 位置1 
        // 缩小窗口
        char tmp = s.charAt(left);
        left++;
        window.put(tmp, window.get(tmp) - 1);
    }
	  // 更新res 位置2
}
```

### 1. 无重复字符的最长子串

使用窗口框选无重复字符的子串，因为需要保证不重复，所以不需要计数，直接使用HashSet作为窗口即可。

因此，使用`HashSet`存储窗口中的字符，窗口大小等于`right - left`，也等于`set.size()`

::: normal-demo  代码实现

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet<>();
        int left = 0, right = 0;
        int res = 0;
        while (right < s.length()) {
            char tmp = s.charAt(right);
            right++;
            while (set.contains(tmp)) {
                char left_char = s.charAt(left);
                left++;
                set.remove(left_char);
            }
            set.add(tmp);
            res = Math.max(res, set.size()); # right - left
        }
        return res;
    }
}
```

:::

### 2. 找到字符串中所有字母异位词

使用两个`HashMap`

- `Map<Character, Integer> need = new HashMap<>();`  记录需要的字符及其数量
- `Map<Character, Integer> window = new HashMap<>();`

用`valid`变量来判断是否覆盖了需要的字符种类，一个字符满足其数量要求才能valid++，因此valid == need.size()的时候认为目前window中有机会存在字母异位词，因此，将valid == need.size()作为缩小窗口的条件。

需要注意`window.get(c)`的值是`Integer`，需要用`equals`进行值的比较；在较小的时候因为有缓存所以相等，数值大的时候就不相等了。

::: normal-demo  代码实现

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        Map<Character, Integer> need = new HashMap<>();
        Map<Character, Integer> window = new HashMap<>();
        for (char c : p.toCharArray()) {
            need.put(c, need.getOrDefault(c, 0) + 1);
        }
        int left = 0, right = 0;
        int valid = 0;
        List<Integer> res = new ArrayList<>();
        while (right < s.length()) {
            char c = s.charAt(right);
            right++;
            // 维护window和valid变量
            window.put(c, window.getOrDefault(c, 0) + 1);
            if (need.containsKey(c) && window.get(c).equals(need.get(c))) {
                valid++;
            }
            while (valid == need.size()) { // 缩小窗口条件
                if (right - left == p.length()) { // 更新结果
                    res.add(left);
                }
                char tmp = s.charAt(left);
                left++;
	              // 维护window和valid变量
                if (need.containsKey(tmp) && window.get(tmp).equals(need.get(tmp))) {
                    valid--;
                }
                window.put(tmp, window.getOrDefault(tmp, 0) - 1);
            }
        }
        return res;
    }
}
```

:::

### 3. 最小覆盖子串

和上面一题思路相同，实现区别在于结果的存储更新和返回，存储字符串起始索引和长度比每次存储字符串本身效率高。

存储结果：`int start = 0, len = Integer.MAX_VALUE;`

更新结果：

```java
if (right - left < len) {
    len = right - left;
    start = left;
}
```

返回结果：`return len == Integer.MAX_VALUE ? "" : s.substring(start, start + len);`

::: normal-demo  代码实现

```java
class Solution {
    public String minWindow(String s, String t) {
        Map<Character, Integer> need = new HashMap<>();
        Map<Character, Integer> window = new HashMap<>();
        for (char c : t.toCharArray()) {
            need.put(c, need.getOrDefault(c, 0) + 1);
        }
        int left = 0, right = 0;
        int valid = 0;
        int start = 0, len = Integer.MAX_VALUE;
        while (right < s.length()) {
            char c = s.charAt(right);
            right++;
            window.put(c, window.getOrDefault(c, 0) + 1);
            if (need.containsKey(c) && window.get(c).equals(need.get(c))) {
                valid++;
            }
            while (valid == need.size()) {
                if (right - left < len) {
                    len = right - left;
                    start = left;
                }
                char tmp = s.charAt(left);
                left++;
                if (need.containsKey(tmp) && window.get(tmp).equals(need.get(tmp))) {
                    valid--;
                }
                window.put(tmp, window.get(tmp) - 1);
            }
        }
        return len == Integer.MAX_VALUE ? "" : s.substring(start, start + len);
    }
}
```

:::

## 四、数组

### 1. 合并区间

这道题很多API细节需要注意：

1. 数组排序，自定义排序方式：

   按照区间左边界升序排列

   ```java
   Arrays.sort(intervals, (a, b) -> {
       return a[0] - b[0];
   })
   ```

2. 返回值要求是`int[][]`，所以定义存储结果的对象是`List<int[]>`，最后返回`res.toArray(new int[0][0]);`

代码求解思路：

> 排序，并将第一个区间放入res。对剩余区间遍历，判断当前区间`int[] cur = intervals[i]`是否和上一个区间`int[] last = res.get(res.size() - 1)`重叠
>
> ``if (cur[0] <= last[1]) `
>
> - 如果重叠：`last[1] = Math.max(intv[1], last[1]);`
> - 如果不重叠：`res.add(intv);`
>
> 返回`int[][]`数组：`return res.toArray(new int[0][0]);`

::: normal-demo  代码实现

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);
        List<int[]> res = new ArrayList<>();
        res.add(intervals[0]);
        for (int i = 1; i < intervals.length; i++) {
            int[] last = res.get(res.size() - 1);
            int[] cur = intervals[i];
            if (cur[0] <= last[1]) {
                last[1] = Math.max(last[1], cur[1]);
            } else {
                res.add(cur);
            }
        }
        return res.toArray(new int[0][0]);
    }
}
```

:::

### 2. 轮转数组

k可能取0或者大于数组长度的数，所以需要取模：`k = k % nums.length;`

两种做法：

1. 使用额外数组轮转填充+然后复制到原来数组

   ::: normal-demo  代码实现

   ```java
   class Solution {
       public void rotate(int[] nums, int k) {
           int[] num_ = new int[nums.length];
           for (int i = 0; i < nums.length; i++) {
               num_[(i + k) % nums.length] = nums[i];
           }
           System.arraycopy(num_, 0, nums, 0, nums.length);
       }
   }
   ```

   :::

2. 三次翻转：调用三次这个函数`reverse(int[] nums, int left, int right)`

   ==`while`循环里面别忘了更新参数值：`left++; right--;`==

   ::: normal-demo  代码实现

   ```java
   class Solution {
       public void rotate(int[] nums, int k) {
           k = k % nums.length;
           reverse(nums, 0, nums.length - 1);
           reverse(nums, 0, k - 1);
           reverse(nums, k, nums.length - 1);
       }
       public void reverse(int[] nums, int left, int right) {
           while (left < right) {
               int tmp = nums[left];
               nums[left] = nums[right];
               nums[right] = tmp;
               left++;
               right--;
           }
       }
   }
   ```

   :::

### 3. 旋转图像

顺时针旋转90度 = `transpose`后，每一行翻转`reverse`

`transpose`转置矩阵：

```java
for (int i = 0; i < m; i++) {
    for (int j = i + 1; j < n; j++) { // 只需要对一半的数进行操作
        int tmp = matrix[i][j];
        matrix[i][j] = matrix[j][i]; // 等于另外一半
        matrix[j][i] = tmp;
    }
}
```

### 4. 除自身以外数组的乘积

难点在于不准使用除法；位置i处的结果等于i左边的数的乘积 * i右边数的乘积

计算左边的数的乘积可以直接在ans数组上进行累乘

计算右边数的乘积用一个tmp来存储，再乘在ans数组上

::: normal-demo  代码实现

```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int[] ans = new int[nums.length];
        ans[0] = 1;
        for (int i = 1; i < nums.length; i++) {
            ans[i] = ans[i - 1] * nums[i - 1];
        }
        int tmp = 1;
        for (int i = nums.length - 2; i >= 0; i--) {
            tmp *= nums[i + 1];
            ans[i] *= tmp;
        }
        return ans;
    }
}
```

:::

### 5. 矩阵置0

不能用岛屿的dfs，因为是需要第一轮为0的行和列变为0，不用递归下去

这题代码有点长，写的时候需要耐心一点

核心在于找到矩阵中含有元素0的所有行和列，然后将其置0

- 使用矩阵的第一行和第一列来存储该行该列是否含有0元素，同时使用额外的两个boolean变量存储第一行第一列是否含有0
- 先对非第一行第一列的元素进行置0
- 然后再通过额外的两个boolean变量对第一行和第一列是否置0进行判断

::: normal-demo  代码实现

```java
class Solution {
    public void setZeroes(int[][] matrix) {
        boolean row_zero = false, col_zero = false;
        int m = matrix.length, n = matrix[0].length;
        for (int j = 0; j < n; j++) {
            if (matrix[0][j] == 0) {
                row_zero = true;
            }
        }
        for (int i = 0; i < m; i++) {
            if (matrix[i][0] == 0) {
                col_zero = true;
            }
        }
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (matrix[i][j] == 0) {
                    matrix[0][j] = 0;
                    matrix[i][0] = 0;
                }
            }
        }
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (matrix[0][j] == 0 || matrix[i][0] == 0) {
                    matrix[i][j] = 0;
                }
            }
        }
        if (row_zero) {
            for (int j = 0; j < n; j++) {
                matrix[0][j] = 0;
            }
        }
        if (col_zero) {
            for (int i = 0; i < m; i++) {
                matrix[i][0] = 0;
            }
        }
    }
}
```

:::

### 6. 螺旋矩阵

设置上下左右边界`int u = 0, d = matrix.length - 1, l = 0, r = matrix[0].length - 1;`

使用`while(true)`对四个边界分别进行遍历，以上边界为例：

- `for (int i = l; i <= r; i++) res.add(matrix[u][i]);`
- `if (++u > b) break;`

::: normal-demo  代码实现

```java
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> res = new ArrayList<>();
        int m = matrix.length, n = matrix[0].length;
        int l = 0, r = n - 1, t = 0, b = m - 1;
        while (true) {
            for (int i = l; i <= r; i++) res.add(matrix[t][i]);
            if (++t > b) break;
            for (int i = t; i <= b; i++) res.add(matrix[i][r]);
            if (--r < l) break;
            for (int i = r; i >= l; i--) res.add(matrix[b][i]);
            if (--b < t) break;
            for (int i = b; i >= t; i--) res.add(matrix[i][l]);
            if (++l > r) break;
        }
        return res;
    }
}
```

:::

### 7. 打乱数组

循环n次，每次对位置i的元素进行随机操作：

- 在 [*i*,*n*) 中随机抽取一个下标 *j*；
- 将第 *i* 个元素与第 *j* 个元素交换

```Python
def shuffle(self) -> List[int]:
    for i in range(len(self.nums)):
        j = random.randrange(i, len(self.nums))
        self.nums[i], self.nums[j] = self.nums[j], self.nums[i]
    return self.nums
```

随机的定义：对于原数组 *nums* 中的任意一个数，被移动到打乱后的数组的任意一个位置的概率是相同的。

证明如下：

- 一个数被移动到第一个位置的概率：1/n
- 一个数被移动到第二个位置的概率：（n-1)/n * 1/(n-1) 第一次没有被选中，第二次被选中

## 五、链表

链表节点ListNode的定义

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
```

会构造一条新的链表（更换头节点/头节点可能会被删除）的情况都需要用到dummy头节点

使用while循环别忘了更新链表往下走

### 找中间节点的位置

1. 回文：让slow在中点靠后的位置，这样slow为头的部分节点数可能较少，用这部分是否遍历到null作为判断结束条件

   ```java
     ListNode fast = head, slow = head;
     while (fast != null && fast.next != null) {
         fast = fast.next.next;
         slow = slow.next;
     }
     if (fast != null) slow = slow.next;
   ```

2. 排序：让slow在中点靠前的位置，这样既能将前后断开，又能获取后半部分链表头节点

   ```java
     ListNode fast = head.next, slow = head; //fast先往前走一步，保证slow在中点靠前的位置
     while (fast != null && fast.next != null) {
         fast = fast.next.next;
         slow = slow.next;
     }
     ListNode tmp = slow.next;
     slow.next = null;
   ```

3. 删除链表的倒数第N个节点：从dummy开始找倒数N+1个节点，fast要先往前走N+1次（有无dummy不影响找倒数第几个节点）

   ```java
     ListNode fast = dummy, slow = dummy;
     for (int i = 0; i < n + 1; i++) {
         fast = fast.next;
     }
     while (fast != null) {
         fast = fast.next;
         slow = slow.next;
     }
   ```


### 1. 相交链表

连接两条链表遍历找相同节点；转到另外一条链表的时候不需要前进，转本身就是向前一步。一次循环里面应该只做一件事，所以需要用if-else语句

::: normal-demo  代码实现

```java
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
    ListNode p1 = headA, p2 = headB;
    while (p1 != p2) {
        if (p1 == null) p1 = headB;
        else p1 = p1.next;
        if (p2 == null) p2 = headA;
        else p2 = p2.next;
    }
    return p1;
}
```

:::

### 2. 反转链表

递归和非递归两种

base case都是：

`if(head == null || head.next == null) return head;`

非递归的循环条件是：

`while (nex != null) `

::: normal-demo  递归-代码实现

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        if (head == null || head.next == null) return head;
        ListNode newHead = reverseList(head.next);
        head.next.next = head;
        head.next = null;
        return newHead;
    }
}
```

:::

::: normal-demo  非递归-代码实现

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        if (head == null || head.next == null) return head;
        ListNode cur = head, pre = null, nex = cur.next;
        while (nex != null) {
            cur.next = pre;
            pre = cur;
            cur = nex;
            nex = nex.next;
        }
        cur.next = pre;
        return cur;
    }
}
```

:::

#### 反转链表 2 （反转区间）

思路

1. 确认要反转的区间[a, b)：找a的prev节点和b节点（不需要反转的nul节点）
2. 反转[a, b)就是反转prev.next，b
3. 得到反转链表头节点和prev连接

注意：

- 需要用到dummy头节点（否则，如果是从头节点开始反转，找不到头节点的前驱节点）
- 最后返回值是dummy.next

::: normal-demo  递归-代码实现

```java
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        ListNode dummy = new ListNode(-1);
        dummy.next = head;
        ListNode a = dummy, b = dummy;
        for (int i = 0; i < left - 1; i++) {
            a = a.next;
        }
        for (int i = 0; i <= right; i++) {
            b = b.next;
        }
        a.next = reverse(a.next, b);
        return dummy.next;
    }
    public ListNode reverse(ListNode head, ListNode nul) {
        if (head == nul || head.next == nul) return head; // ⚠️ 这里是nul不是null
        ListNode newHead = reverse(head.next, nul);
        head.next.next = head;
        head.next = nul;
        return newHead;
    }
}
```

:::

#### K个一组反转链表

有两个递归问题

- 原问题等于 反转最开始的K个节点，然后对这K个节点之后的的链表进行K个一组反转链表
- 反转最开始的K个节点：用反转链表2（反转区间）的解法，也就是找到长度为k的区间[a, b)并反转

::: normal-demo  递归-代码实现

```java
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode b = head;
        for (int i = 0; i < k; i++) {
            if (b == null) return head;
            b = b.next;
        }
        ListNode newHead = reverseBetween(head, b);
        head.next = reverseKGroup(b, k);
        return newHead;
    }
    public ListNode reverseBetween(ListNode head, ListNode nul) {
        if (head == nul || head.next == nul) return head;
        ListNode newHead = reverseBetween(head.next, nul);
        head.next.next = head;
        head.next = nul;
        return newHead;
    }
}
```

:::

### 3. 回文链表

快慢指针找中点+反转中点后的链表+判断回文

::: normal-demo  递归解法-代码实现

```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        ListNode fast = head, slow = head;
        ListNode p = head;
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
        }
        if (fast != null) slow = slow.next;
        slow = reverseList(slow);
        while (slow != null) {
            if (slow.val != p.val) return false;
            slow = slow.next;
            p = p.next;
        }
        return true;
    }
    public ListNode reverseList(ListNode head) {
        if (head == null || head.next == null) return head;
        ListNode newHead = reverseList(head.next);
        head.next.next = head;
        head.next = null;
        return newHead;
    }
}
```

:::

- 递归（外部指针，后序遍历，递归到最后再开始判断）**（有点难掌握TODO）**

### 4. 环形链表

判断是否有环，并返回环节点

快慢指针判断是否有环；将fast移动到head，一起移动找环节点

解法数理推导：假设slow走了k步，则fast走了2k步，头节点到相遇点的距离是slow走的k步。假设环节点到相遇点的距离为m，则头节点到环节点的距离为k-m，相遇点到环节点的距离为2k - k -m = k - m。因此，将一个指针移动到头节点，然后一起同步移动，相遇的点即为环节点。

::: normal-demo  代码实现

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode fast = head, slow = head;
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
            if (fast == slow) break;
        }
        if (fast == null || fast.next == null) return null;
        fast = head;
        while (fast != slow) {
            fast = fast.next;
            slow = slow.next;
        }
        return slow;
    }
}
```

:::

### 5. 合并两个有序链表

dummy头节点，记得要对p1/p2剩余部分做连接

::: normal-demo  代码实现

```java
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode dummy = new ListNode(-1), p = dummy;
        ListNode p1 = list1, p2 = list2;
        while (p1 != null && p2 != null) {
            if (p1.val <= p2.val) {
                p.next = p1;
                p1 = p1.next;
            } else {
                p.next = p2;
                p2 = p2.next;
            }
            p = p.next;
        }
        if (p1 != null) p.next = p1;
        if (p2 != null) p.next = p2;
        return dummy.next;
    }
}
```

:::

#### 排序链表

找链表中点归并排序 + 合并两个有序链表

1. 找链表中点前一个节点，断开前后连接
2. 递归调用本函数排序前后两个链表
3. 合并两个有序链表

::: normal-demo  代码实现

```java
public ListNode sortList(ListNode head) {
    if (head == null || head.next == null) return head;
    ListNode fast = head.next, slow = head;
    while (fast != null && fast.next != null) {
        fast = fast.next.next;
        slow = slow.next;
    }
    ListNode p2 = slow.next;
    slow.next = null;
    p2 = sortList(p2);
    ListNode p1 = sortList(head);
    return mergeTwoLists(p1, p2);
}
```

:::

#### 合并K个升序链表

借助最小堆（优先级队列）来快速找到多个链表中最小的链表节点：把k个链表的头节点放进去

新链表由dummy节点引导，返回值为dummy.next

循环条件是最小堆不为空：每次从最小堆中取出最小的节点，连接到新链表中[用p]，并把它的下一个节点放进最小堆

::: normal-demo  代码实现

```java
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);
        for (ListNode head : lists) {
            if (head != null) { // 对head为空的处理放在这里
                pq.offer(head);
            }
        }
        ListNode dummy = new ListNode(-1), p = dummy;
        while (!pq.isEmpty()) {
            ListNode tmp = pq.poll();
            if (tmp.next != null) pq.offer(tmp.next);
            p.next = tmp;
            p = p.next;
        }
        return dummy.next;
    }
}
```

:::

### 6. 两数相加

注意循环条件包括对两个链表是否为空的判断，以及是否还存在进位

::: normal-demo  代码实现

```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        int carry = 0;
        ListNode dummy = new ListNode(-1), p = dummy;
        while (l1 != null || l2  != null || carry != 0) {
            int a = 0, b = 0;
            if (l1 != null) {
                a = l1.val;
                l1 = l1.next;
            }
            if (l2 != null) {
                b = l2.val;
                l2 = l2.next;
            }
            int sum = a + b + carry;
            carry = sum / 10;
            p.next = new ListNode(sum % 10);
            p = p.next;
        }
        return dummy.next;
    }
}
```

:::

### 7. 删除链表的倒数第N个节点

头节点可能会被删除，所以需要添加dummy头节点，先连接到原链表上

因为要删除倒数第N个节点，所以需要找到倒数第N个节点的前一个节点，也就是倒数第N + 1个节点。

::: normal-demo  代码实现

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(-1);
        dummy.next = head;
        ListNode fast = dummy, slow = dummy;
        for (int i = 0; i <= n; i++) {
            fast = fast.next;
        }
        while (fast != null) {
            fast = fast.next;
            slow = slow.next;
        }
        slow.next = slow.next.next;
        return dummy.next;
    }
}
```

:::

### 8. 随机链表的复制

数据结构的复制：哈希表+两次遍历

第一次遍历：复制节点，并在哈希表中存储<原始节点，复制节点>

第二次遍历：组装连接节点

::: normal-demo  代码实现

```java
class Solution {
    public Node copyRandomList(Node head) {
        Map<Node, Node> ori2Clone = new HashMap<>();
        for (Node p = head; p != null; p = p.next) {
            if (!ori2Clone.containsKey(p)) {
                ori2Clone.put(p, new Node(p.val));
            }
        }
        for (Node p = head; p != null; p = p.next) {
            if (p.next != null) {
                ori2Clone.get(p).next = ori2Clone.get(p.next);
            }
            if (p.random != null) {
                ori2Clone.get(p).random = ori2Clone.get(p.random);
            }
        }
        return ori2Clone.get(head);
    }
}
```

:::

### 9. LRU缓存 

直接使用`LinkedHashMap<Integer,Integer>` 

::: normal-demo  代码实现

```java
class LRUCache {
    LinkedHashMap<Integer, Integer> map;
    int cap;
    public LRUCache(int capacity) {
        cap = capacity;
        map = new LinkedHashMap<>();
    }
    
    public int get(int key) {
        if (map.containsKey(key)) {
            makeRecently(key);
            return map.get(key);
        }
        return -1;
    }
    
    public void put(int key, int value) {
        if (map.containsKey(key)) {
            map.put(key, value);
            makeRecently(key);
            return;
        }
        if (map.size() >= cap) {
            int old = map.keySet().iterator().next();
            map.remove(old);
        }
        map.put(key, value);
    }

    public void makeRecently(int key) {
        int val = map.get(key);
        map.remove(key);
        map.put(key, val);
    }
}
```

:::

自己实现`LinkedHashMap<Integer, Integer>`

- 哈希表`Map<Integer, Node> map;`：用于快速查找
- 双向链表的`Node`类，存储key，value和前后两个Node节点：用于添加缓存、移除最近最少使用的缓存、将当前缓存移动到最后
  - `makeRecent(cur)`
    - `remove(cur)`
    - `addLast(cur)`
  - `addLast(cur)`
  - `removeFirst()`
    - `remove(cur)`
  

::: normal-demo  代码实现

```java
class LRUCache {
    class Node {
        int key;
        int val;
        Node prev;
        Node next;
        Node () {}
        Node (int key, int val) {
            this.key = key;
            this.val = val;
        }
    }

    Node head, tail;
    Map<Integer, Node> map;
    int cap;
    public LRUCache(int capacity) {
        cap = capacity;
        head = new Node();
        tail = new Node();
        head.next = tail;
        tail.prev = head;
        map = new HashMap<>();
    }
    
    public int get(int key) {
        if (!map.containsKey(key)) return -1;
        Node find = map.get(key);
        makeRecent(find);
        return find.val;
    }
    
    public void put(int key, int value) {
        if (map.containsKey(key)) {
            Node tmp = map.get(key);
            tmp.val = value;
            makeRecent(tmp);
        } else {
            if (map.size() >= cap) {
                Node old = removeFirst();
                map.remove(old.key);
            }
            Node newNode = new Node(key, value);
            addLast(newNode);
            map.put(key, newNode);
        }
    }
    public void makeRecent(Node node) {
        remove(node);
        addLast(node);
    }

    public Node removeFirst() {
        if (head.next == tail) return null;
        Node first = head.next;
        remove(first);
        return first;
    }

    public void remove(Node node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }

    public void addLast(Node node) {
        node.next = tail;
        node.prev = tail.prev;
        tail.prev.next = node;
        tail.prev = node;
    }
}
```

:::

## 七、二分查找

使用情况：知道解的范围，而且可以根据中间结果缩小查找范围

- 华为线下一面手撕：对可能的最短时间进行二分查找
- 百度提前批一面：求平方根


### 代码框架

```java
public int search(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) return mid;
        if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return -1;
}
```

搜素左侧边界：

```java
public int searchInsert(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) right = mid - 1; // 注意
        if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return left; // 注意，返回left
}
```

这里返回值的含义是：

1. `target`应该插入的索引位置（保持原数组有序）
2. `nums[left]` 是数组中大于等于`target`的最小元素
3. 数组中小于`target`的元素个数

### 1. 搜索二维矩阵

矩阵升序排列

二分查找，将`index`映射到矩阵中坐标

```java
// m x n矩阵
i = index / n;
j = index % n
```

### 2. 搜索二维矩阵 II

- 每行的元素从左到右升序排列。
- 每列的元素从上到下升序排列。

从右上角开始搜索，目标值更小则向左，否则向下搜索

```java
public boolean searchMatrix(int[][] matrix, int target) {
    int m = matrix.length, n = matrix[0].length;
    int i = 0, j = n - 1;
    while (i <= m - 1 && j >= 0) {
        if (matrix[i][j] == target) return true;
        if (matrix[i][j] < target) {
            i++;
        } else {
            j--;
        }
    }
    return false;
}
```

### 3. 在排序数组中查找元素的第一个和最后一个位置

注意没有元素的时候：`if(nums.length == 0) return new int[]{-1, -1};`

分别查找改元素的左侧边界和右侧边界

```Python
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        if len(nums) == 0: return [-1, -1]
        left = self.left_bound(nums, target)
        right = self.right_bound(nums, target)
        return [left, right]
    def left_bound(self, nums, target):
        left = 0
        right = len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        if left >= len(nums) or nums[left] != target:
            return -1
        return left
    def right_bound(self, nums, target):
        left = 0
        right = len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] > target:
                right = mid - 1
            else:
                left = mid + 1
        if right < 0 or nums[right] != target:
            return -1
        return right
```

### 4. 搜索旋转排序数组

数组总有一段是升序的，在有序的段里面进行二分查找判断

- 判断0到mid之间是否有序：` nums[0] <= nums[mid]`	
  - 取等号是为了兼容只有一个元素的情况，否则会认为`[mid, nums.length - 1]`是升序


- 有序的一段需要对两边（最小值和最大值）都做判断，看是否在这段范围中：

  - `nums[0] <= target && target < nums[mid]`

  - `nums[mid] < target && target <= nums[len - 1]`


```Java
class Solution {
    public int search(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) return mid;
            if (nums[0] <= nums[mid]) {
                if (nums[0] <= target && target < nums[mid]) {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            } else {
                if (nums[mid] < target && target <= nums[nums.length - 1]) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
        }
        return -1;
    }
}
```

### 5. 寻找旋转排序数组中的最小值

通过和末尾元素比较来缩小查找区间

```java
public int findMin(int[] nums) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] <= nums[right]) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    return nums[left];
}
```

<img src="https://my-kk-blog.oss-cn-shanghai.aliyuncs.com/img/image-20240908231317087.png" alt="image-20240908231317087" style="zoom:50%;" />

### 6. 求平方根

输入在0-1的情况搜索范围是[0,1]

```Python
class Solution:
    def mySqrt(self, x: int) -> int:
        left = 0
        if x >= 1:
            right = x
        else:
            right = 1
        ans = 1
        while left <= right:
            mid = (left + right) // 2
            if mid ** 2 <= x:
                ans = mid
                left = mid + 1
            else:
                right = mid - 1
        return ans
```

### 7. 有序数组中的缺失元素

https://blog.csdn.net/qq_29051413/article/details/108679642

## 八、栈

### 常用API

`Stack`

- `push()`
- `pop()`
- `peek()`

### 1. 最小栈

使用两个栈来实现，其中一个栈专门存另一个栈的最小元素

```Java
class MinStack {
    Stack<Integer> s, mins;

    public MinStack() {
        s = new Stack<>();
        mins = new Stack<>();
    }
    
    public void push(int val) {
        s.push(val);
        if (mins.isEmpty() || mins.peek() > val) {
            mins.push(val);
        } else {
            mins.push(mins.peek());
        }
    }
    
    public void pop() {
        s.pop();
        mins.pop();
    }
    
    public int top() {
        return s.peek();
    }
    
    public int getMin() {
        return mins.peek();
    }
}
```

### 2. 每日温度

> 给定一个整数数组 `temperatures` ，表示每天的温度，返回一个数组 `answer` ，其中 `answer[i]` 是指对于第 `i` 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。

栈里面存温度数组的索引，倒序入栈：

- 使用while循环把比当前元素小的元素索引都pop出去
- 使用栈顶元素计算结果：`res[i] = s.isEmpty() ? 0 : s.peek() - i;`
- push当前元素

```java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        Stack<Integer> s = new Stack<>();
        int n = temperatures.length;
        int[] res = new int[n];
        for (int i = n - 1; i >= 0; i--) {
            while (!s.isEmpty() && temperatures[s.peek()] <= temperatures[i]) {
                s.pop();
            }
            res[i] = s.isEmpty() ? 0 : s.peek() - i;
            s.push(i);
        }
        return res;
    }
}
```

### 3. 有效的括号

判断输入的括号是否是有效的：

```java
public boolean isValid(String s) {
    Stack<Character> stack = new Stack<>();
    for (char c : s.toCharArray()) {
        if (c == '(' || c == '[' || c == '{'){
            stack.push(c);
            continue;
        } else if (stack.isEmpty() || stack.pop() != leftOf(c)) {
            return false;
        }
    }
    return stack.isEmpty(); 
}
private char leftOf(char c) {
    if (c == ']') return '[';
    if (c == ')') return '(';
    return '{';
}
```

### 4. 最长有效括号

主要思路：用栈去记录最后一个没有被匹配的括号的下标

一开始的时候往栈中放入一个值为 −1 的元素，表示目前可以开始被匹配的位置是0。

从前往后遍历字符串

- 对于遇到的每个 ‘(’ ，我们将它的下标放入栈中；
- 对于遇到的每个 ‘)’ ，我们先弹出栈顶元素表示匹配了当前右括号：
  - 如果栈为空，说明当前的右括号为没有被匹配的右括号，push下标入栈
  - 如果栈不为空，
    - 计算以该右括号为结尾的最长有效括号的长度：当前右括号的下标减去栈顶元素
    - 尝试更新最长有效括号长度

```Java
class Solution {
    public int longestValidParentheses(String s) {
        int maxans = 0;
	      Stack<Integer> stack = new Stack<>();
        stack.push(-1);
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == '(') {
                stack.push(i);
            } else {
                stack.pop();
                if (stack.isEmpty()) {
                    stack.push(i);
                } else {
                    maxans = Math.max(maxans, i - stack.peek());
                }
            }
        }
        return maxans;
    }
}

作者：力扣官方题解
链接：https://leetcode.cn/problems/longest-valid-parentheses/solutions/314683/zui-chang-you-xiao-gua-hao-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

## 九、队列

### 常用API

1. 队列`Queue`实现了一个先进先出（FIFO）的数据结构：

   - 通过`add()`/`offer()`方法将元素添加到队尾；
   - 通过`remove()`/`poll()`从队首获取元素并删除；
   - 通过`element()`/`peek()`从队首获取元素但不删除。

2. PriorityQueue 优先级队列，基于优先级堆（最小堆）实现，API和Queue的相同

   `Queue<Integer> q = new PriorityQueue<>();`

   `isEmpty()`

   `size()`

   在插入和删除操作后，`PriorityQueue` 会自动进行堆化操作，以保持堆的性质。

3. `LinkedList`既实现了`List`接口，又实现了`Queue`接口，但是，在使用的时候，如果我们把它当作List，就获取List的引用，如果我们把它当作Queue，就获取Queue的引用：

   ```java
   // 这是一个List:
   List<String> list = new LinkedList<>();
   // 这是一个Queue:
   Queue<String> queue = new LinkedList<>();
   ```

### 1. 滑动窗口的最大值（链表实现单调队列）

使用LinkedList实现MonotonicQueue单调队列（递减），头元素是最大值

通常用于解决一些滑动窗口的最值问题

```java
class Solution {
    class MonotonicQueue {
        LinkedList<Integer> mq = new LinkedList<>();
        public void push(int n) {
            while (!mq.isEmpty() && mq.getLast() < n) {
                mq.removeLast();
            }
            mq.addLast(n);
        }
        public int max() {
            return mq.getFirst();
        }
        public void pop(int n) {
            if (mq.getFirst() == n) {
                mq.removeFirst();
            }
        }
    }

    public int[] maxSlidingWindow(int[] nums, int k) {
        MonotonicQueue mq = new MonotonicQueue();
        int[] res = new int[nums.length - k + 1];
        for (int i = 0; i < k; i++) {
            mq.push(nums[i]);
        }
        res[0] = mq.max();
        for (int i = 1; i + k - 1 < nums.length; i++) {
            mq.pop(nums[i - 1]);
            mq.push(nums[i + k - 1]);
            res[i] = mq.max();
        }
        return res;
    }
}
```

## 十、堆

### 1. 数组中的第K个最大元素

本质就是考排序

- 实现最大堆的构建和堆排序算法

```Java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        heapify(nums);
        heapSort(nums);
        return nums[nums.length - k];
    }
    private void heapSort(int[] nums) {
        int n = nums.length;
        for (int i = n - 1; i > 0; i--) {
            swap(nums, 0, i);
            heapifyDown(nums, 0, i);
        }
    }
    private void heapify(int[] nums) {
        int n = nums.length;
        for (int i = (n - 1 - 1) / 2; i >= 0; i--) {
            heapifyDown(nums, i, n);
        }
    }
    private void heapifyDown(int[] nums, int i, int n) {
        int left = 2 * i + 1;
        int right = 2 * i + 2;
        int largest = i;
        if (left < n && nums[left] > nums[largest]) {
            largest = left;
        }
        if (right < n && nums[right] > nums[largest]) {
            largest = right;
        }
        if (largest != i) {
            swap(nums, i, largest);
            heapifyDown(nums, largest, n);
        }
    }
    private void swap(int[] nums, int a, int b) {
        int temp = nums[a];
        nums[a] = nums[b];
        nums[b] = temp;
    }
}
```

### 2. 前K个高频元素

直接用优先级队列：

```Java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        HashMap<Integer, Integer> valToFreq = new HashMap<>();
        for (int v : nums) {
            valToFreq.put(v, valToFreq.getOrDefault(v, 0) + 1);
        }
        PriorityQueue<Map.Entry<Integer, Integer>> pq = new PriorityQueue<>((a, b) -> {
            return b.getValue() - a.getValue();
        });

        for (Map.Entry<Integer,Integer> entry : valToFreq.entrySet()) {
            pq.offer(entry);
        }
        int[] res = new int[k];
        for (int i = 0; i < k; i++) {
            res[i] = pq.poll().getKey();
        }
        return res;
    }
}
```

