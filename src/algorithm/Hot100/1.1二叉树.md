---
title: äºŒå‰æ ‘
order: 2

copyright: <a href="https://creativecommons.org/licenses/by-nc/4.0/">CC BY-NC 4.0åè®®</a>
---

### è¿­ä»£éå†äºŒå‰æ ‘

#### å‰åºéå†

push(root)ï¼› å–æ ˆé¡¶å…ƒç´ å¹¶è®¿é—®ï¼›push rightã€push left

```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if (root == null) return res;
        Stack<TreeNode> s = new Stack<>();
        s.push(root);
        while (!s.isEmpty()) {
            TreeNode cur = s.pop();
            if (cur.right != null) {
                s.push(cur.right);
            }
            if (cur.left != null) {
                s.push(cur.left);
            }
            res.add(cur.val);
        }
        return res;
    }
}
```

#### ä¸­åºéå†

ref: https://www.geeksforgeeks.org/implement-binary-search-treebst-iterator/

ä¸­åºéå†ï¼šå½“å¤©èŠ‚ç‚¹éœ€è¦å·¦å­æ ‘è®¿é—®è¿‡æ‰èƒ½è®¿é—®

- å€ŸåŠ©pushAllLeftè¾…åŠ©å‡½æ•°
- ç¬¬ä¸€ä¸ªè¦è®¿é—®çš„èŠ‚ç‚¹æ˜¯leftä¸ºç©ºçš„èŠ‚ç‚¹ï¼Œç„¶åå¯¹å…¶rightåšç›¸åŒéå†

  ```Java
  class Solution {
      Stack<TreeNode> s = new Stack<>();
      public List<Integer> inorderTraversal(TreeNode root) {
          List<Integer> res = new ArrayList<>();
          if (root == null) return res;
          pushAllLeft(root);
          while (!s.isEmpty()) {
              TreeNode cur = s.pop();
              if (cur.right != null) {
                  pushAllLeft(cur.right);
              }
              res.add(cur.val);
          }
          return res;
      }
      public void pushAllLeft(TreeNode root) {
          TreeNode cur = root;
          while (cur != null) {
              s.push(cur);
              cur = cur.left;
          }
      }
  }
  ```



```java
class Solution {
    public int kthSmallest(TreeNode root, int k) {
        Deque<TreeNode> stack = new ArrayDeque<TreeNode>();
        while (root != null || !stack.isEmpty()) {
            while (root != null) {
                stack.push(root);
                root = root.left;
            }
            root = stack.pop();
            --k;
            if (k == 0) {
                break;
            }
            root = root.right;
        }
        return root.val;
    }
}

ä½œè€…ï¼šåŠ›æ‰£å®˜æ–¹é¢˜è§£
```



#### ååºéå†

å½“å‰èŠ‚ç‚¹éœ€è¦å·¦å³å­æ ‘éƒ½è®¿é—®è¿‡æ‰èƒ½è®¿é—®

ä¸ä¸­åºçš„æ¯”è¾ƒï¼š

- ä¸­åºéå†ä¸­ï¼Œä»æ ˆä¸­å¼¹å‡ºçš„èŠ‚ç‚¹ï¼Œå…¶å·¦å­æ ‘æ˜¯è®¿é—®å®Œäº†ï¼Œå¯ä»¥ç›´æ¥è®¿é—®è¯¥èŠ‚ç‚¹ï¼Œå†å»æŒ‰ç…§ç›¸åŒé€»è¾‘è®¿é—®å³å­æ ‘
- ååºéå†ä¸­ï¼Œä»æ ˆä¸­å¼¹å‡ºçš„èŠ‚ç‚¹ï¼Œæˆ‘ä»¬åªèƒ½ç¡®å®šå…¶å·¦å­æ ‘è‚¯å®šè®¿é—®å®Œäº†ï¼Œä½†æ˜¯æ— æ³•ç¡®å®šå³å­æ ‘æ˜¯å¦è®¿é—®è¿‡ã€‚å› æ­¤ï¼Œéœ€è¦å¼•å…¥ä¸€ä¸ªprevè®°å½•å†å²è®¿é—®è®°å½•
  - é€šè¿‡`cur.right == null || prev == cur.right`æ¥åˆ¤æ–­æ˜¯å¦å¯ä»¥è®¿é—®å½“å‰èŠ‚ç‚¹
    - è®¿é—®ï¼Œç”¨prevæŒ‡å‘è¯¥èŠ‚ç‚¹
    - ä¸èƒ½è®¿é—®ï¼Œå°†è¯¥èŠ‚ç‚¹é‡æ–°å‹æ ˆï¼Œå¹¶`pushAllLeft(cur.right);`

```java
class Solution {
    Stack<TreeNode> s = new Stack<>();
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if (root == null) return res;
        pushAllLeft(root);
        TreeNode prev = null;
        while (!s.isEmpty()) {
            TreeNode cur = s.pop();
            if (cur.right == null || prev == cur.right) {
                res.add(cur.val);
                prev = cur;
            } else {
                s.push(cur);
                pushAllLeft(cur.right);
            }
        }
        return res;
    }
    public void pushAllLeft(TreeNode root) {
        TreeNode cur = root;
        while (cur != null) {
            s.push(cur);
            cur = cur.left;
        }
    }
}
```



### æ·±å…¥ç†è§£è¿­ä»£å’Œé€’å½’

ğŸŒ°å•é“¾è¡¨å’Œæ•°ç»„çš„éå†å¯ä»¥æ˜¯è¿­ä»£çš„ï¼Œä¹Ÿå¯ä»¥æ˜¯é€’å½’çš„

åªè¦æ˜¯é€’å½’å½¢å¼çš„éå†ï¼Œéƒ½å¯ä»¥æœ‰å‰åºä½ç½®å’Œååºä½ç½®ï¼Œåˆ†åˆ«åœ¨é€’å½’ä¹‹å‰å’Œé€’å½’ä¹‹å

**äºŒå‰æ ‘æ— éå°±æ˜¯äºŒå‰é“¾è¡¨**ï¼Œç”±äºæ²¡åŠæ³•ç®€å•æ”¹å†™æˆè¿­ä»£å½¢å¼ï¼Œæ‰€ä»¥ä¸€èˆ¬äºŒå‰æ ‘çš„éå†æ¡†æ¶éƒ½æ˜¯é€’å½’çš„å½¢å¼

æ—¶é—´å¤æ‚åº¦è¿˜æ˜¯`O(n)`

```Java
/* è¿­ä»£éå†æ•°ç»„ */
void traverse(int[] arr) {
    for (int i = 0; i < arr.length; i++) {

    }
}

/* é€’å½’éå†æ•°ç»„ */
void traverse(int[] arr, int i) {
    if (i == arr.length) {
        return;
    }
    // å‰åºä½ç½®
    traverse(arr, i + 1);
    // ååºä½ç½®
}

/* è¿­ä»£éå†å•é“¾è¡¨ */
void traverse(ListNode head) {
    for (ListNode p = head; p != null; p = p.next) {

    }
}

/* é€’å½’éå†å•é“¾è¡¨ */
void traverse(ListNode head) {
    if (head == null) {
        return;
    }
    // å‰åºä½ç½®
    traverse(head.next);
    // ååºä½ç½®
}
```

ğŸŒ°å€’åºæ‰“å°å•é“¾è¡¨èŠ‚ç‚¹å€¼

```Java
void traverse(ListNode head) {
	if (head == null) {
		return;
	}
	traverse(head.next);
	print(head.val);
}
```



**å‰ä¸­ååºçš„åŒºåˆ«åœ¨äºå¤„ç†æ¯ä¸ªèŠ‚ç‚¹çš„æ—¶é—´ç‚¹**

äºŒå‰æ ‘é—®é¢˜ï¼šåœ¨å‰ä¸­ååºä½ç½®æ³¨å…¥å·§å¦™çš„ä»£ç é€»è¾‘ï¼Œå»è¾¾åˆ°è‡ªå·±çš„ç›®çš„ï¼Œåªéœ€è¦å•ç‹¬æ€è€ƒæ¯ä¸€ä¸ªèŠ‚ç‚¹åº”è¯¥åšä»€ä¹ˆ



### å›æº¯æ€è·¯å’ŒåŠ¨æ€è§„åˆ’çš„æ€è·¯

å›æº¯æ˜¯ä¸€æ­¥ä¸€æ­¥åšçš„ï¼Œç»“æœå­˜æ”¾åœ¨å¤–éƒ¨å˜é‡ä¸­ï¼›å…³æ³¨è·¯å¾„ï¼Œç®—æ³•æ¡†æ¶å¦‚ä¸‹:

```Java
void backtrack(...) {
    for (int i = 0; i < ...; i++) {
        // åšé€‰æ‹©
        ...

        // è¿›å…¥ä¸‹ä¸€å±‚å†³ç­–æ ‘
        backtrack(...);

        // æ’¤é”€åˆšæ‰åšçš„é€‰æ‹©
        ...
    }
}
```

åŠ¨æ€è§„åˆ’æ˜¯æ ¹æ®base caseã€çŠ¶æ€è½¬ç§»æ–¹ç¨‹æ¥å†³å®šçš„ï¼›ä¸éœ€è¦é¢å¤–çš„è¾…åŠ©å‡½æ•°å’Œå¤–éƒ¨å˜é‡ï¼›å…³æ³¨å­é—®é¢˜å’Œå­é—®é¢˜ç»“æœ

æ™®é€šçš„DFSéå†å…³æ³¨çš„æ˜¯èŠ‚ç‚¹

ğŸŒ°æ±‚å‰åºåºåˆ—

```Java
// å›æº¯
List<Integer> res = new LinkedList<>();

// è¿”å›å‰åºéå†ç»“æœ
List<Integer> preorderTraverse(TreeNode root) {
    traverse(root);
    return res;
}

// äºŒå‰æ ‘éå†å‡½æ•°
void traverse(TreeNode root) {
    if (root == null) {
        return;
    }
    // å‰åºä½ç½®
    res.add(root.val);
    traverse(root.left);
    traverse(root.right);
}

```

```Java
// åŠ¨æ€è§„åˆ’
// å®šä¹‰ï¼šè¾“å…¥ä¸€æ£µäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œè¿”å›è¿™æ£µæ ‘çš„å‰åºéå†ç»“æœ
List<Integer> preorderTraverse(TreeNode root) {
    List<Integer> res = new LinkedList<>();
    if (root == null) {
        return res;
    }
    // å‰åºéå†çš„ç»“æœï¼Œroot.val åœ¨ç¬¬ä¸€ä¸ª
    res.add(root.val);
    // åˆ©ç”¨å‡½æ•°å®šä¹‰ï¼Œåé¢æ¥ç€å·¦å­æ ‘çš„å‰åºéå†ç»“æœ
    res.addAll(preorderTraverse(root.left));
    // åˆ©ç”¨å‡½æ•°å®šä¹‰ï¼Œæœ€åæ¥ç€å³å­æ ‘çš„å‰åºéå†ç»“æœ
    res.addAll(preorderTraverse(root.right));
    return res;
}
```

> å­˜åœ¨é—®é¢˜ï¼š**ç®—æ³•çš„å¤æ‚åº¦ä¸å¥½æŠŠæ§**ï¼Œæ¯”è¾ƒä¾èµ–è¯­è¨€ç‰¹æ€§ã€‚Java çš„è¯æ— è®º ArrayList è¿˜æ˜¯ LinkedListï¼Œ`addAll` æ–¹æ³•çš„å¤æ‚åº¦éƒ½æ˜¯ O(N)ï¼Œæ‰€ä»¥æ€»ä½“çš„æœ€åæ—¶é—´å¤æ‚åº¦ä¼šè¾¾åˆ° O(N^2)



### å‰åºå’Œååºçš„åŒºåˆ«

ğŸŒ°æ ¹èŠ‚ç‚¹çœ‹åšç¬¬ 1 å±‚ï¼Œæ‰“å°å‡ºæ¯ä¸€ä¸ªèŠ‚ç‚¹æ‰€åœ¨çš„å±‚æ•°

```Java
// äºŒå‰æ ‘éå†å‡½æ•°
void traverse(TreeNode root, int level) {
    if (root == null) {
        return;
    }
    // å‰åºä½ç½®
    printf("èŠ‚ç‚¹ %s åœ¨ç¬¬ %d å±‚", root, level);
    traverse(root.left, level + 1);
    traverse(root.right, level + 1);
}

// è¿™æ ·è°ƒç”¨
traverse(root, 1);
```



ğŸŒ°æ‰“å°å‡ºæ¯ä¸ªèŠ‚ç‚¹çš„å·¦å³å­æ ‘èŠ‚ç‚¹æ•°é‡

```Java
// å®šä¹‰ï¼šè¾“å…¥ä¸€æ£µäºŒå‰æ ‘ï¼Œè¿”å›è¿™æ£µäºŒå‰æ ‘çš„èŠ‚ç‚¹æ€»æ•°
int count(TreeNode root) {
    if (root == null) {
        return 0;
    }
    int leftCount = count(root.left);
    int rightCount = count(root.right);
    // ååºä½ç½®
    printf("èŠ‚ç‚¹ %s çš„å·¦å­æ ‘æœ‰ %d ä¸ªèŠ‚ç‚¹ï¼Œå³å­æ ‘æœ‰ %d ä¸ªèŠ‚ç‚¹",
            root, leftCount, rightCount);

    return leftCount + rightCount + 1;
}
```

é‡åˆ°å­æ ‘é—®é¢˜ï¼Œé¦–å…ˆæƒ³åˆ°çš„æ˜¯ç»™å‡½æ•°è®¾ç½®è¿”å›å€¼ï¼Œç„¶ååœ¨ååºä½ç½®åšæ–‡ç« ã€‚





## äºŒå‰æ ‘ Hot100

æ ‘èŠ‚ç‚¹TreeNodeçš„å®šä¹‰ï¼š

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
```

BSTï¼šäºŒå‰æœç´¢æ ‘/æŸ¥æ‰¾æ ‘

è§£é¢˜çš„ä¸¤ç§æ€è·¯ï¼š

- åˆ†è§£é—®é¢˜/è‡ªé¡¶å‘ä¸‹çš„æ€è·¯ï¼Œå»æ€è€ƒå¦‚æœä¸‹é¢çš„èŠ‚ç‚¹éƒ½åšå¥½äº†ï¼Œè¿™ä¸ªèŠ‚ç‚¹è¦åšä»€ä¹ˆäº‹ï¼Œä¹Ÿå°±æ˜¯æ˜ç¡®é€’å½’å‡½æ•°çš„å®šä¹‰ï¼Œç„¶ååˆ©ç”¨è¿™ä¸ªå®šä¹‰ï¼ˆè¿™ç§ä¸€èˆ¬å¯ä»¥ç›´æ¥åœ¨ä¸€ä¸ªå‡½æ•°ä¸­å®Œæˆï¼‰

- éå†çš„æ€è·¯ï¼Œä¸€èˆ¬éœ€è¦é¢å¤–å®šä¹‰ä¸€ä¸ªtraverseå‡½æ•°

  - å‰åºã€ä¸­åºã€ååº

    ```java
    void traverse(TreeNode root) {
        if (root == null) {
            return;
        }
        // å‰åºä½ç½®
        traverse(root.left);
        // ä¸­åºä½ç½® BSTäºŒå‰æŸ¥æ‰¾/æœç´¢æ ‘çš„ä¸­åºéå†æ˜¯æœ‰åºçš„
        traverse(root.right);
        // ååºä½ç½®
    }
    ```

  - å±‚åºï¼šå€ŸåŠ©é˜Ÿåˆ—

    ```java
    // è¾“å…¥ä¸€æ£µäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œå±‚åºéå†è¿™æ£µäºŒå‰æ ‘
    void levelTraverse(TreeNode root) {
        if (root == null) return;
        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);
    
        // ä»ä¸Šåˆ°ä¸‹éå†äºŒå‰æ ‘çš„æ¯ä¸€å±‚
        while (!q.isEmpty()) {
            int sz = q.size(); // ç¡®å®šå½“å‰å±‚æœ‰å¤šå°‘ä¸ªèŠ‚ç‚¹éœ€è¦éå†
            // ä»å·¦åˆ°å³éå†æ¯ä¸€å±‚çš„æ¯ä¸ªèŠ‚ç‚¹
            for (int i = 0; i < sz; i++) {
                TreeNode cur = q.poll();
                // å°†ä¸‹ä¸€å±‚èŠ‚ç‚¹æ”¾å…¥é˜Ÿåˆ—
                if (cur.left != null) {
                    q.offer(cur.left);
                }
                if (cur.right != null) {
                    q.offer(cur.right);
                }
            }
        }
    }
    ```

### 1. äºŒå‰æ ‘çš„ç›´å¾„ ref(10)

è¾…åŠ©å‡½æ•°`getHeight`åœ¨è®¡ç®—æœ€å¤§æ·±åº¦çš„åŒæ—¶æ›´æ–°å˜é‡`maxDia`

::: normal-demo  ä»£ç å®ç°

```java
public int getHeight(TreeNode root) {
    if (root == null) return 0;
    int leftHeight = getHeight(root.left);
    int rightHeight = getHeight(root.right);
    // è®¡ç®—æœ€å¤§æ·±åº¦çš„è¿‡ç¨‹ä¸­æ›´æ–°æœ€å¤§ç›´å¾„
	  // æ¯ä¸ªèŠ‚ç‚¹çš„ç›´å¾„æ˜¯å…¶å·¦å­æ ‘æœ€å¤§æ·±åº¦+å³å­æ ‘æœ€å¤§æ·±åº¦
    maxDia = Math.max(maxDia, leftHeight + rightHeight); 
    return Math.max(leftHeight, rightHeight) + 1; //è®¡ç®—æœ€å¤§æ·±åº¦
}
```

:::

#### å¹³è¡¡äºŒå‰æ ‘

å€ŸåŠ©è¾…åŠ©å‡½æ•°`getHeight(TreeNode root)`è®¡ç®—å½“å‰èŠ‚ç‚¹çš„æœ€å¤§æ·±åº¦ï¼ŒåŒæ—¶åˆ¤æ–­æ˜¯å¦å¹³è¡¡

- å¹³è¡¡ï¼šè¿”å›æ ‘æœ€å¤§æ·±åº¦
- ä¸å¹³è¡¡ã€é«˜åº¦å·®è¶…è¿‡1ã€‘ï¼šè¿”å›-1

::: normal-demo  ä»£ç å®ç°

```java
class Solution {
    public boolean isBalanced(TreeNode root) {
        return getHeight(root) != -1;
    }
    public int getHeight(TreeNode root) {
        if (root == null) return 0;
        int leftHeight = getHeight(root.left);
        if (leftHeight == -1) return -1; // å‰ªæï¼Œå¦‚æœå·¦å­æ ‘ä¸å¹³è¡¡ï¼Œè‚¯å®šæ•´ä¸ªæ ‘ä¸å¹³è¡¡
        int rightHeight = getHeight(root.right);
        if (rightHeight == -1) return -1; // å‰ªæï¼Œå¦‚æœå³å­æ ‘ä¸å¹³è¡¡ï¼Œè‚¯å®šæ•´ä¸ªæ ‘ä¸å¹³è¡¡
        return Math.abs(leftHeight - rightHeight) <= 1 ? Math.max(leftHeight, rightHeight) + 1 : -1;
    }
```

:::

### 2. å°†æœ‰åºæ•°ç»„è½¬åŒ–ä¸ºäºŒå‰æœç´¢æ ‘

è‡ªé¡¶å‘ä¸‹ï¼š`return traverse(nums, 0, nums.length - 1);`

`traverse`å‡½æ•°æ€è·¯ï¼š

- Base Caseï¼š`if (left > right) return null;`

- æ‰¾ä¸­é—´èŠ‚ç‚¹ï¼Œæ„é€ èŠ‚ç‚¹ï¼š

  ```java
  int mid = left + (right - left) / 2;
  TreeNode root = new TreeNode(nums[mid]);
  ```

- å·¦å³èŠ‚ç‚¹åˆ†åˆ«é€’å½’æ„é€ 

  - `root.left = traverse(nums, left, mid - 1);`
  - `root.right = traverse(nums, mid + 1, right);`

::: normal-demo  ä»£ç å®ç°

```java
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        return traverse(nums, 0, nums.length - 1);
    }
    public TreeNode traverse(int[] nums, int left, int right) {
        if (left > right) return null;
        int mid = left + (right - left) / 2;
        TreeNode root = new TreeNode(nums[mid]);
        root.left = traverse(nums, left, mid - 1);
        root.right = traverse(nums, mid + 1, right);
        return root;
    }
}
```

:::

### 3. éªŒè¯äºŒå‰æœç´¢æ ‘

::: normal-demo  ä»£ç å®ç°

```java
class Solution {
    public boolean isValidBST(TreeNode root) {
        return isValid(root, null, null); //è‡ªé¡¶å‘ä¸‹
    }
    public boolean isValid(TreeNode root, TreeNode min, TreeNode max) {
        if (root == null) return true;
        if (max != null && root.val >= max.val) return false; //æ³¨æ„==ä¹Ÿæ˜¯ä¸æ»¡è¶³çš„
        if (min != null && root.val <= min.val) return false;
        return isValid(root.left, min, root) && isValid(root.right, root, max);
    }
}
```

:::

### 4. äºŒå‰æœç´¢æ ‘ä¸­ç¬¬kå°çš„å…ƒç´ 

BSTçš„ä¸­åºéå†ç»“æœæ˜¯æœ‰åºçš„ï¼Œæ‰€ä»¥è¦æ‰¾çš„æ˜¯ä¸­åºéå†çš„ç¬¬kä¸ªå…ƒç´ ï¼Œä½¿ç”¨`traverse`å‡½æ•°éå†

ä½¿ç”¨å…¨å±€å˜é‡rankè®¡æ•°ï¼Œä½¿ç”¨å…¨å±€å˜é‡reså­˜å‚¨ç»“æœã€‚

::: normal-demo  ä»£ç å®ç°

```java
class Solution {
    int rank = 0;
    int res = -1;
    public int kthSmallest(TreeNode root, int k) {
        traverse(root, k);
        return res;
    }
    public void traverse(TreeNode root, int k) {
        if (root == null) return;
        if (rank > k) return; // å‰ªæ
        traverse(root.left, k);
        rank++;
        if (rank == k) {
            res = root.val;
            return;
        }
        traverse(root.right, k);
    }
}
```

:::

### 5. äºŒå‰æ ‘çš„å³è§†å›¾

å±‚åºéå†ï¼›æ³¨æ„ä¸æ˜¯ç›´æ¥å³å­æ ‘éå†ï¼Œå› ä¸ºéœ€è¦è€ƒè™‘ä¸€å±‚ä¸­å³ä¾§ä¸ºç©ºä½†å·¦ä¾§ä»ç„¶èŠ‚ç‚¹çš„æƒ…å†µã€‚

::: normal-demo  ä»£ç å®ç°

```java
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        Queue<TreeNode> q = new LinkedList<>();
        if (root == null) return res;
        q.offer(root);
        while (!q.isEmpty()) {
            int sz = q.size();
            for (int i = 0; i < sz; i++) {
                TreeNode tmp = q.poll();
                if (tmp.left != null) q.offer(tmp.left);
                if (tmp.right != null) q.offer(tmp.right);
                if (i == sz - 1) res.add(tmp.val);
            }
        }
        return res;
    }
}
```

:::

### 6. äºŒå‰æ ‘å±•å¼€ä¸ºé“¾è¡¨

è‡ªé¡¶å‘ä¸‹

é—®é¢˜åˆ†è§£ä¸ºï¼š

1. å±•å¼€å·¦å­æ ‘
2. å±•å¼€å³å­æ ‘
3. è¿æ¥ï¼š
   1. `root.right = root.left;`
   2. `root.left = null;`
   3. æ‰¾åˆ°å³ä¾§æœ«å°¾ï¼Œè¿æ¥å±•å¼€çš„å³å­æ ‘

::: normal-demo  ä»£ç å®ç°

```java
class Solution {
    public void flatten(TreeNode root) {
        if (root == null) return;
        flatten(root.left);
        flatten(root.right);
        TreeNode tmp = root.right;
        root.right = root.left;
        root.left = null;

        TreeNode p = root;
        while (p.right != null) {
            p = p.right;
        }
        p.right = tmp;
    }
}
```

:::

### 7. ä»å‰åºå’Œä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘

éœ€è¦å€ŸåŠ©HashMapå¿«é€Ÿæ‰¾åˆ°inorderä¸­èŠ‚ç‚¹ç´¢å¼•:

- `Map<Integer, Integer> val2Index;`
- éå†inorderæ•°ç»„ï¼š`val2Index.put(inorder[i], i);`

é€’å½’å‡½æ•°ï¼šä¸æ–­æ„é€ æ ¹èŠ‚ç‚¹

```Java
class Solution {
    Map<Integer, Integer> val2index;
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        val2index = new HashMap<>();
        int i = 0;
        for (int num : inorder) {
            val2index.put(num, i++);
        }
        return buildTree(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1);
    }
    public TreeNode buildTree(int[] preorder, int p_left, int p_right, int[] inorder, int i_left, int i_right) {
        if (p_left > p_right) return null;
        TreeNode root = new TreeNode(preorder[p_left]);
        int index = val2index.get(preorder[p_left]);
        // left len = index - i_left
        root.left = buildTree(preorder, p_left + 1, p_left + index - i_left, inorder, i_left, index - 1);
        root.right = buildTree(preorder, p_left + index - i_left + 1, p_right, inorder, index + 1, i_right);
        return root;
    }
}
```

### 8. è·¯å¾„æ€»å’Œ 

- å’Œä¸ºkçš„å­æ•°ç»„ + å›æº¯

ä½¿ç”¨`Map<Long, Integer> map;`å­˜å‚¨å½“å‰è·¯å¾„ä¸Šçš„å‰ç¼€å’ŒåŠå…¶å‡ºç°æ¬¡æ•°

Base Caseï¼š` map.put(0L, 1);`

å‰åºéå†ï¼š`traverse(root, 0L);`

```java
class Solution {
    Map<Long, Integer> map;
    int target;
    public int pathSum(TreeNode root, int targetSum) {
        target = targetSum;
        map = new HashMap<>();
        map.put(0L, 1);
        return traverse(root, 0L);
    }
    public int traverse(TreeNode root, Long preSum) {
        if (root == null) return 0;
        preSum += root.val;

        int res = map.getOrDefault(preSum - target, 0);
        map.put(preSum, map.getOrDefault(preSum, 0) + 1); // æ·»åŠ è·¯å¾„ä¸Šå½“å‰å‰ç¼€å’Œ
        int left = traverse(root.left, preSum);
        int right = traverse(root.right, preSum);
        map.put(preSum, map.get(preSum) - 1); // ç§»é™¤è·¯å¾„ä¸Šå½“å‰å‰ç¼€å’Œ
        return res + left + right;
    }
}
```

### 9. æœ€è¿‘å…¬å…±ç¥–å…ˆ

`lowestCommonAncestorg`å‡½æ•°å®šä¹‰ä¸ºï¼šåœ¨rootä¸­æ‰¾pã€qçš„æœ€è¿‘å…¬å…±ç¥–å…ˆ

- è¿”å›å€¼ä¸ºnullï¼šrootä¸­ä¸å­˜åœ¨è¿™ä¸¤ä¸ªå…ƒç´ 
- è¿”å›å€¼ä¸ä¸ºnullï¼šè¿”å›çš„æ˜¯rootä¸‹çš„ä¸¤è€…çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ

```java
        if (left == null && right == null) return null;
        if (left != null && right != null) return root;
        return left == null ? right : left;
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) 
        // base case
        if (root == null || root == p || root == q) return root;
        TreeNode left_ = lowestCommonAncestor(root.left, p, q);
        TreeNode right_ = lowestCommonAncestor(root.right, p, q);
        // å¯¹å·¦å³å­æ ‘é€’å½’ç»“æœåšåˆ¤æ–­ï¼š
        if (left_ == null && right_ == null) return null;
        if (left_ != null && right_ != null) return root;
        return left_ == null ? right_ : left_;
    }
}
```

### 10. äºŒå‰æ ‘ä¸­çš„æœ€å¤§è·¯å¾„å’Œ

å®šä¹‰å…¨å±€å˜é‡ï¼š`int maxSum = Integer.MIN_VALUE;`

ä½¿ç”¨è¾…åŠ©å‡½æ•°ï¼š`getMaxSum(root);` è®¡ç®—ä»¥rootèŠ‚ç‚¹ä¸ºèµ·ç‚¹çš„æœ€å¤§è·¯å¾„å’Œ

- Base Caseï¼š`if (root == null) return 0;`

```java
class Solution {
    int maxSum = Integer.MIN_VALUE;
    public int maxPathSum(TreeNode root) {
        getMaxSum(root);
        return maxSum;
    }

    public int getMaxSum(TreeNode root) {
        if (root == null) return 0;
        int left = Math.max(getMaxSum(root.left), 0); // å–æ­£æ•°
        int right = Math.max(getMaxSum(root.right), 0); // å–æ­£æ•°
        maxSum = Math.max(left + right + root.val, maxSum); // æ›´æ–°å…¨å±€å˜é‡ maxSum
        return Math.max(left, right) + root.val;
    }
}
```

